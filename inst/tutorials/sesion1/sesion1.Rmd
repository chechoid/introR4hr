---
title: "Sesi칩n 1 - Introducci칩n a R y Tidyverse"
output: 
  learnr::tutorial:
  theme: spacelab
runtime: shiny_prerendered
description: "Tutorial de la Clase 1 del Curso Introducci칩n a R para RRHH"
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)

# Datasets
library(openxlsx)
library(tidyverse)

#carpeta <- "inst/tutorials/sesion1/"

plantel <- read.xlsx("plantel.xlsx")
salarios <- read.xlsx("puestos.xlsx")

empleados <- left_join(plantel, salarios, by = "ID")

mensualizados <- plantel %>% 
  left_join(salarios, by ="ID") %>% 
  filter(!is.na(PUESTO))

encuesta <- read.csv("https://raw.githubusercontent.com/r4hr/kiwi2020/main/rh_ar.csv",
                     sep = ";")
```

## Sesi칩n 1 - Introducci칩n a Tidyverse

![Estados de 치nimo de lxs programadores](images/mood_coder.png){width="40%"}

Este tutorial corresponde a la clase de **Introducci칩n a la limpieza de datos con Tidyverse** del curso Introducci칩n a R para RRHH de [Data 4HR](https://data-4hr.com/capacitacion/curso-introduccion-r-para-rrhh/).

Con este tutorial vas a poder practicar algunas de las funciones de `tidyverse`, una colecci칩n de paquetes dise침adas para *"domar datos"*: limpiar, filtrar, seleccionar, y transformas los datos para que se ajusten a nuestras necesidades de an치lisis.

Record치 que cont치s con los siguientes canales de comunicaci칩n para hacer consultas:

游뱋 [Slack](https://join.slack.com/t/r4hr/shared_invite/zt-ocriyx5e-nqXuwWeDyOKm2ICUJjhu6g)

游니 [Discord](https://discord.gg/3xhNH6kRad)

En Slack tenemos un canal llamado **#auxilio** donde pod칠s hacer todas las consultas que quieras.

Muchas gracias!

**Sergio Garcia Mora \| Data 4HR**

![](https://i.creativecommons.org/l/by-nc/4.0/88x31.png)

**Sergio Garcia Mora** **Data 4HR**

## Proyectos

Los proyectos son una de las grandes ventajas de trabajar con RStudio. Internamente crea carpetas dentro de *Mis documentos* (o la carpeta que elijas) haciendo que tu c칩digo y los datos est칠n almacenados organizadamente, redireccionando las carpetas de trabajo cada vez que cambias de proyecto.

Para crear un proyecto primero hay que entrar en *File -\> New Project* y se abrir치 una ventana como la siguiente:

![](images/new_project.png){width="348"}

Elegimos la opci칩n *New Directory* en la ventana siguiente volvemos a hacer click en *New Project* y luego en la siguiente ventana, podemos elegir el nombre del proyecto, elegir la carpeta en la que queremos guardarlo con el bot칩n *Browse*.

![](images/new_projecto.png)

Arriba a la derecha, debajo del 칤cono para cerrar el programa RStudio va a aparecer un 칤cono de un cubo celeste con el nombre del proyecto que acabamos de crear. Desde el men칰 desplegable podemos intercambiar de proyectos cada vez que lo necesitemos.

## Repaso: Objetos

R es un lenguaje orientado a objetos. Esto quiere decir que las tablas, valores y resultados, les podemos dar un nombre, y utilizar ese nombre para que sea m치s f치cil operar y programar los scripts.

> Recomendaci칩n: Pon칠 nombres claros y descriptivos a los objetos, que sean breves, pero a su vez que den una pista sobre lo que contiene. Record치 que ac치 lo m치s importante no es que R entienda lo que est치s haciendo, sino que lo pueda entender otra persona, e incluso vos mismo cuando vuelvas a leer tu propio script dentro de 6 meses o un a침o.

Algo interesante con los objetos es que podemos utilizarlos y operar con ellos en los scripts.

Para crear un objeto podemos usar el s칤mbolo `<-` (la *"flechita"*), o bien el signo igual `=`. En R preferimos usar la *flechita* como asignador porque el signo igual se usa mucho en la modificaci칩n de par치metros de funciones.

### Ejercicio

El costo de la rotaci칩n seg칰n el [Dr. Jac Fitz-enz](https://www.linkedin.com/in/dr-jac-fitzenz-89782a55/), el padre de la rotaci칩n en RRHH es de 6 sueldos para personas de convenio o semi seniors, o hasta **un sueldo anual** en el caso de managers o profesionales.

Es decir que la forma de calcular el costo de la rotaci칩n anual, asumiendo que estamos haciendo un c치lculo conservador (6 meses) es:

\$ Sueldo Promedio x 6 x Cantidad Bajas \$

As칤 con las siguientes presunciones vamos a calcular el costo de rotaci칩n de tu organizaci칩n.

-   Crea un objeto que se llame `sueldo_referencia` cuyo monto sea de USD 1.000.
-   Crea un objeto llamado `bajas` con la cantidad de personas desvinculadas. Tom치 el n칰mero de egresos de la compa침칤a en la que trabajas en los 칰ltimos 12 meses, o simplemente inventa un n칰mero cualquiera.

Usa los objetos para calcular el costo de rotaci칩n.

```{r objeto, exercise = TRUE, exercise.lines = 9}
# Crea los valores de referencia
sueldo_referencia <- 1000
bajas ___ ______

# Calcular el costo de rotaci칩n multiplicando ambos objetos por 6
costo_rotacion <- sueldo_referencia * ___ * _______

# Ver el resultado
costo_rotacion
```

```{r objeto-hint-1}
# Asigna el elemento 'bajas' un valor cualquiera. Por ejemplo, las desvinculaciones en tu empresa en los 칰ltimos 12 meses 
# Para calcular el costo de rotaci칩n multiplica sueldo_referencia * 6 * bajas
```

```{r objeto-hint-2}
# Crea los valores de referencia
sueldo_referencia <- 1000
bajas <- 18

# Calcular el costo de rotaci칩n multiplicando ambos objetos por 6
costo_rotacion <- sueldo_referencia * 6 * bajas

# Ver el resultado
costo_rotacion
```

## Repaso: Vectores

Los vectores son conjuntos de datos. Los creamos con una funci칩n llamada `c()` que significa *combine* (combinar).

Por ejemplo:

```{r vec-ej1}
# Vector num칠rico
numeros <- c(16, 8, 42)

# Vector de texto
texto <- c("RH", "People Analytics", "IA")

# Ver sus contenidos
numeros
texto
```

쯈u칠 tipo de vector genera este c칩digo?

```{r vec-ej2, eval=FALSE}
ejercicio <- c("1", 7, 9)
```

```{r vec-quizz}
quiz(
  question("쯈u칠 tipo de vector genera el c칩digo anterior?",
           answer("Num칠rico", message = "Si bien son tres valores num칠ricos, el hecho de que el primero est칠 entre comillas, hace que R lo considere un tipo de dato character o de texto"),
           answer("Texto", correct = TRUE, message = "Correcto! Cuando a un n칰mero lo escribimos entre comillas R lo interpreta como texto"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE
)
)
```

Para seleccionar elementos de un vector tenemos que seguir la l칩gica `nombre_vector[numero_posicion]`.

```{r vec-ej3, exercise = TRUE, exercise.lines =8}
# Crear un vector
area <- c("RH", "HR Analytics", "IA")

# Seleccionar el segundo elemento
_______

# Modificar el segundo elemento por 'People Analytics'
____[__] <- ____________
```

```{r vec-ej3-hint-1}
# Para elegir un elemento de un vector pone el nombre del vector y entre corchetes el n칰mero del elemento
# Para asignar un valor hay que usar la estructura nombre_vector[elemento] y asignar el nuevo elemento

```

```{r vec-ej3-hint-2}
# Crear un vector
area <- c("RH", "HR Analytics", "IA")

# Seleccionar el segundo elemento
area[2]

# Modificar el segundo elemento por 'People Analytics'
area[2] <- "People Analytics"
```


## Repaso: Data frames

Los *data frames* son tablas, como las que encontramos en cualquier archivo de Excel por ejemplo, en donde tenemos filas (observaciones) y columnas (variables).

Si tenemos vectores que tienen la misma cantidad de elementos, podemos usar la funci칩n `data.frame()` pasando los nombres de los vectores dentro de la funci칩n.

Por ejemplo, creemos dos vectores, uno con el nombre de las 치reas de `RH`, `Finanzas` y `Operaciones`, y otro con la cantidad de colaboradores, por ejemplo: `6`, `12`, `24` respectivamente. Luego con esos vectores podemos crear un data frame llamado `dotacion`.

```{r df-1, exercise = TRUE, exercise.lines = 9}
# Crear los vectores 'area' y 'cantidad'
area <- c("RH", _______, ______)
cantidad ___ _(____, _____, _____)

# Crear el data frame usando la funci칩n data.frame()
_______ <-  data.frame(________, ________)

# Ver el data frame
___________________
```

```{r df-1-hint-1}
# Asigna los 3 elementos a cada vector

# Crea un nuevo objeto llamado 'dotacion' 

# Escribe dentro del data frame los nombres de los vectores

# Para ver el data frame escribe su nombre
```

```{r df-1-hint-2}
# Crear los vectores 'area' y 'cantidad'
area <- c("RH", "Finanzas", "Operaciones")
cantidad <- c(6, 12, 24)

# Crear el data frame usando la funci칩n data.frame()
dotacion <- data.frame(area, cantidad)

# Ver el data frame
dotacion
```


Corre la siguiente l칤nea de c칩digo y responde la pregunta a continuaci칩n:

```{r df-2, exercise=TRUE}
# El data frame plantel ya est치 cargado
str(plantel) # Brinda informaci칩n sobre la estructura del data frame
```

Responde la pregunta:

```{r df-3}
quiz(
  question(
    
  )
)
```


## Paquetes

Los paquetes o librer칤as son extensiones desarrolladas por la comunidad o por empresas que facilitan el uso de R y expanden sus capacidades. En este encuentro vamos a usar los siguientes paquetes:

-   `readxl`: Desarrollado por Hadley Wickham and Jennifer Bryan. [Link a la web](https://CRAN.R-project.org/package=readxl).
-   `openxlsx`: Desarrollado por Philipp Schauberger and Alexander Walker. [Link a la web](https://CRAN.R-project.org/package=openxlsx).
-   `tidyverse`: Desarrollado por Hadley Wickham y muchos m치s. [Link a la web](https://www.tidyverse.org/).

Este 칰ltimo paquete, `tidyverse` es una colecci칩n de paquetes que permiten realizar muchas tareas de exploraci칩n, limpieza y transformaci칩n de datos.

Para utilizar un paquete, lo primero que tenemos que hacer es instalarlos. Eso lo hacemos con la funci칩n `install.packages()` y dentro del par칠ntesis tenemos que poner el nombre del paquete. **Tengan en cuenta que:**

-   R es un lenguaje *case sensitive* o sea que hay que prestar atenci칩n a may칰sculas y min칰sculas.

-   Para instalar los paquetes hay que usar comillas

Este es un paso que hacemos una sola vez por computadora.

Para correr el c칩digo se tienen que parar en la l칤nea de c칩digo que quieren usar y apretar las teclas `Ctrl` + `Enter` o bien el tri치ngulo verde (como si fuera un 칤cono de *"Play"* 郊윒잺)

```{r paquetes, eval = FALSE}
# Instalar los paquetes readxl y tidyverse
install.packages("tidyverse")
install.packages("readxl")
```

Esto lo que hace es instalar paquetes desde [CRAN](https://cran.r-project.org/), que es un repositorio donde se publican los paquetes, asegurando un est치ndar de calidad y de documentaci칩n que hace que trabajar con cualquier paquete de CRAN sea seguro.

Para usar las funciones de los paquetes que instalamos, ahora tenemos que **cargarlos.** Esto lo que hace es de alguna manera *"activar"* el paquete y que podamos empezar sus funciones.

Para cargar un paquete tenemos que usar la funci칩n `library()`. Recuerden prestar atenci칩n a las may칰sculas y min칰sculas. Ahora no son necesarias las comillas.

```{r carga-paquetes, exercise = TRUE}
# Cargar los paquetes readxl y tidyverse
library(____)  # Leer archivos de Excel en R


```
```{r carga-paquetes-hint1}
# Ten칠s que usar la funci칩n library() y dentro de los par칠ntesis escribir readxl

```
```{r carga-paquetes-solution}
# Cargar los paquetes readxl y tidyverse
library(readxl) # Leer archivos de Excel en R
```


Una de las formas en las que nos damos cuenta que el paquete est치 instalado es cuando empezamos a escribir su nombre y nos aparece el nombre del paquete para autocompletar. Esta es una de las ventajas de trabajar en RStudio.

![](Archivos/paquete_activo.png)

> Recuerden:
>
> La instalaci칩n de los paquetes se hace **una sola vez** por computadora.
>
> La carga de los paquetese se hace **cada vez que se abre** un script.

### Preguntas

En este primer ejercicio tendr치s que corregir el c칩digo para activar el paquete `tidyverse`. 쮺u치l es la funci칩n que ten칠s que usar para lograrlo?

```{r activar-paquete, exercise = TRUE, exercise.lines = 4}
_______(tidyverse)
```

```{r activar-paquete-hint}
# Para instalar o activar un paquete revisa que el nombre no tenga errores de tipeo.
# R es case sensitive, controla que las may칰sculas o min칰sculas est칠n bien.
# Recuerda que no son necesarias las comillas.
library(tidyverse)
```

```{r paquetes}
quiz(
  question("쮺u치ntas veces hay que instalar un paquete?",
           answer("Una sola vez por computadora", correct = TRUE, "As칤 es! Este es un proceso que se hace por 칰nica vez en cada m치quina en la que trabajes"),
           answer("Cada vez que corremos un script", message = "La instalaci칩n s칩lo es necesaria una sola vez"),
           answer("Cada vez que creamos un proyecto nuevo", message = "No importa la cantidad de proyectos. Cada vez que instalamos un paquete queda disponible para todos los proyectos que creemos."),
           answer("Depende", message = "[Depende](https://youtu.be/dgf5QlcyTFY) es una bonita canci칩n de Jarabe de Palo y en este caso es una respuesta incorrecta ;p"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE),
  question("Cada vez que abro un script es necesario correr la funci칩n `library()`",
           answer("Verdadero", correct = TRUE, message = "Si, es correcto, cada vez que abrimos R tenemos que correr el script desde el principio y vover a activar los paquetes."),
           answer("Falso", message = "Cada vez que abrimos el script hay que correr todo el c칩digo desde el principio y activar el paquete con la funci칩n library"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE),
  question("쯇or qu칠 aparece este mensaje de error?: 'no se pudo encontrar la funci칩n _________'",
  answer("Porque el paquete no est치 instalado", message = "Es posible, pero hay otra respuesta m치s espec칤fica"),
  answer("Porque no cargamos el paquete con la funci칩n library() antes", correct = TRUE, message = "Perfecto! La funci칩n library() activa las funciones"),
  answer("Porque est치 mal escrito el nombre del paquete", message = "Si hay un error de tipeo el mensaje dir칤a: there is no package called ___"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE
))
```

Es un buen momento para [poner una pausa](https://youtu.be/xxLhW_hnrW4).

## Tidyverse

![](images/tidyverse_packages.png){width="438"}

`tidyverse` es un conjunto de paquetes, dise침ados principalmente para la manipulaci칩n y transformaci칩n de datos. Tambi칠n es un est치ndar, conocido como *tidy data* en el cual sus principios son:

* Cada variable debe tener su propia columna.
* Cada observaci칩n debe estar en su propia fila.
* Cada valor debe estar en su propia celda.

![Fuente: R para Ciencia de Datos](https://es.r4ds.hadley.nz/diagrams_w_text_as_path/es/tidy-1.svg)

Un ejemplo t칤pico de lo que tenemos que hacer es cuando en un archivo de Excel nos encontramos con algo as칤:

![Datos Anchos](images/datos_anchos.png)

Para R, enero, febrero, y marzo son valores de una variable que se llamar칤a mes. Si necesito hacer c치lculos o un gr치fico con sus resultados necesito poner esa variable en una columna en vez de en un fila como est치 ahora.

![Datos largos](images/datos_largos.png)

En este primer curso trabajamos mucho con el paquete `dplyr` que nos permite filtrar datos, unir datos de diversas fuentes, y hacer las transformaciones necesarias para poder realizar nuestros an치lisis. Para saber m치s del resto de los paquetes de tidyverse busc치 en el [Google Drive](https://drive.google.com/drive/folders/1Qck3z_t6XLRXb2vbN-00931DgdJZ0yse?usp=sharing) de **R4HR Club de R para RRHH** o mir치 los videos en [YouTube](https://youtube.com/playlist?list=PLZuVytUJrxQlcqu6l-P3ou4vV2mRJU2Ka).

## Funciones o verbos de dplyr

Ten칠 a mano el [cheatsheet de data-wrangling](https://drive.google.com/file/d/1ViFJRuby7FTDgjWvp9P6hKO3MEHgeH_M/view?usp=sharing) en castellano. Los cheatsheets (machetes, cola, trencito, torpedo, chuleta, copiat칤n, plage, chanchullo) son ayuda memorias con las principales funciones de un paquete.

Las funciones que vimos en el curso (que no son todas las del paquete) son:

-   **left_join():** Permite unir informaci칩n de varias tablas. Los sistemas de gesti칩n de RRHH tienen por ejemplo una tabla que tiene informaci칩n b치sica de las personas (nombre y apellido, fecha de nacimiento, etc.), otra tabla con la remuneraci칩n base y los conceptos salariales que le correspondan, y podr칤a tener otras tablas con las evaluaciones de desempe침o y as칤 sucesivamente. Hay muchos tipos distintos de `join`, pero a los fines pr치cticos de este curso nos quedaremos con `left_join()` que es una funci칩n equivalente a realizar un *buscarv* o un *vlookup* en Excel.

-   **select():** Permite seleccionar las columnas con las que queremos trabajar. Tambi칠n permite acomodarlas en el orden que las necesitemos, y tambi칠n la podemos usar para descartar variables que no necesitemos.

-   **filter():** Nos permite filtrar las filas que cumplan con una o m치s condiciones. Por ejemplo, si queremos hacer un an치lisis de un grupo espec칤fico de empleados (por ejemplo L칤deres), vamos a filtrar de una tabla de empleados, los empleados que tengan una posici칩n de liderazgo.

-   **group_by():** Por ejemplo, si quiero analizar los sueldos promedios por puesto, un paso previo que tenemos que hacer es *agrupar* los datos por la variable `puesto` antes de calcular el promedio. Es un paso previo que realizaremos siempre antes de hacer alg칰n c치lculo de resumen estad칤stico.

-   **summarise():** Es la funci칩n que nos permite hacer c치lculos de resumen estad칤stico (calcular promedios, medianas, contar filas, desv칤os est치ndares, etc.). Lo

-   **mutate():** Uno de los principales usos de `mutate()` es el de crear una nueva variable (columna) en nuestro dataframe original en base a alguna columna que ya exista. Por ejemplo, si tengo una columna que contenga el sueldo b치sico mensual de un empleado, podr칤a a침adir otra columna que calcule las cargas sociales, o bien el costo anual de cada colaborador/a. Otro uso que se le da es para modificar las caracter칤sticas de una variable (lo veremos en un ejercicio).

## El "pipe" %>%

Uno de los paquetes de tidyverse, el paquete `dplyr` aporta un s칤mbolo conocido como *"pipe"* `%>%` (*tubo* en ingl칠s). El atajo de teclado es con las teclas *Ctrl + May칰s + M* en Windows, o *Cmd + Shift + M* en Mac.

A partir de la versi칩n 4.1.0 de R, hay una versi칩n nativa de R del *pipe* cuyo s칤mbolo es `|>` pero en este curso utilizaremos la versi칩n del paquete `dplyr`.

Lo que nos permite este *pipe* o *tubo* es escribir los c칩digos en secuencias, haciendo much칤simo m치s f치cil escribir y leer secuencias de funciones que incluyan varios pasos.

Imaginemos que queremos comprar regalos por el d칤a del ni침o a todos los empleados de la empresa que tengan hijos. Para esto, necesitamos un listado de los empleados que tengan hijos, ordenados por sector. Para lograr esto los pasos que tenemos que seguir son:

1.  Seleccionar las columnas `AREA`, `ID` e `HIJOS` del dataframe `nomina`.

2.  Filtrar los empleados que tengan hijos (donde en la columna `HIJOS` el valor sea mayor que cero.

3.  Ordenar los resultados por `AREA`.

Veamos c칩mo se ve el c칩digo de R sin el uso del pipe `%>%`:

```{r ej3, echo=TRUE, eval=FALSE}
# Ejemplo de funciones anidadas sin usar el pipe
arrange(filter(select(nomina, AREA,ID, HIJOS), HIJOS > 0), AREA)
```

Ahora veamos el siguiente c칩digo, que logra lo mismo que antes, pero usando el pipe `%>%`

```{r ej4, echo=TRUE, eval=FALSE}
# Ejemplo de funciones anidadas usando el pipe
nomina %>% 
  select(AREA, ID, HIJOS) %>% 
  filter(HIJOS > 0) %>% 
  arrange(AREA)
```

쮺u치l te parece la forma m치s sencilla de entender la secuencia de an치lisis?

## Unir datos con left_join()

Tenemos dos dataframes, uno con informaci칩n general de los empleados. El dataframe `plantel` contiene 8 variables:

-   ID: el dato de identificaci칩n 칰nica de cada persona de la empresa.

-   ANTIGUEDAD: Los a침os de permanencia en la organizaci칩n.

-   EDAD: La edad de los colaboradores.

-   ESTADO_CIVIL: El estado civil de los trabajadores/as de la compa침칤a.

-   HIJOS: La cantidad de hijos que tiene cada colaborador.

-   AREA: El sector en el que trabaja cada persona.

-   ID_CAT: La clave identificatoria de las categor칤as de los trabajadores.

-   N_CATEG: El nombre de cada categor칤a.

Veamos la estructura del dataframe.

```{r str1, exercise = TRUE}
#Correr este c칩digo
str(plantel)
```

El siguiente dataframe, `salarios` contiene los siguientes campos:

-   ID: el campo que nos permitir치 unir las diferentes tablas.

-   PUESTO: el nombre real del puesto que ocupa cada persona.

-   SUELDO: La remuneraci칩n b치sica mensual de cada empleado.

Prest치 atenci칩n a la estructura del archivo y contesta la siguiente pregunta.

```{r str2, exercise = TRUE}
str(salarios)
```

```{r left-q}
quiz(
  question("쮺u치ntas filas y columnas tiene el dataframe 'salarios'?",
  answer("135 columnas y 3 variables", message = "Las observaciones son las filas y las variables son las columnas de una tabla o data frame."),
  answer("130 filas y 10 variables", message = "Mir치 de nuevo el resultado de la estructura del dataframe salarios. Primero indica las observaciones, y luego las variables"),
  answer("135 filas y 3 columnas", correct = TRUE, message = "Muy bien!"),
  submit_button = "Enviar respuesta",
  try_again_button = "Intenta de nuevo",
  allow_retry = TRUE
))
```

Ahora vamos a unir ambos dataframes en uno solo para poder hacer nuestros an치lisis.

Usaremos la funci칩n `left_join()` para agregar al dataframe `plantel` los datos del dataframe `salarios.`

```{r leftjoin, exercise = TRUE, exercise.lines=7}
# Agrega al dataframe 'plantel' el dataframe 'salarios'
empleados <- left____(_____, _____, by = "ID")

# Ver la estructura del nuevo dataframe
___(__________)
```

```{r leftjoin-hint}
# Recuerda poner la funci칩n left_join()
# A침ade al dataframe 'plantel', los datos de 'salarios' por la columna ID
# Cuidado con may칰sculas y min칰sculas
# Para ver la estructura del data frame usa la funci칩n str(nombre_dataframe)
```

```{r leftjoin-solution}
empleados <- left_join(plantel, salarios, by = "ID")

# Ver la estructura del nuevo dataframe
str(empleados)
```

Hay muchos tipos de `join`, por ejemplo `right_join`, `inner_join`, `anti_join`, `full_join`, que no ser치n parte de este curso.

## select()

Con la funci칩n `select()` podemos elegir las columnas que nos interesa trabajar. Por ejemplo, prueba de correr la funci칩n `str()` con el nuevo dataframe `empleados`.

Esta es una funci칩n particularmente 칰til cuando trabajamos con datasets muy grandes que contienen muchas columnas y filas, que mejora los tiempos de procesamiento de datos.

```{r str, exercise = TRUE, exercise.lines = 4}
# Corre esta l칤nea de c칩digo
str(empleados)
```

Las variables `EDAD`, `ESTADO_CIVIL` e `HIJOS` no tienen mucho sentido para un an치lisis salarial. En el pr칩ximo ejercicio, selecciona las columnas `ID`, `AREA`, `PUESTO`, `SUELDO` y `ANTIGUEDAD` y guarda la selecci칩n en un objeto llamado `mensuales.`

```{r select, exercise = TRUE, exercise.lines = 4}
mensuales <- empleados %>% 
  _______(___, ___, ____, ____)
```

```{r select-hint-1}
# Usa la funci칩n select()
# Dentro del par칠ntesis pon los nombres de las variables que nos interesa analizar
```

```{r select-hint-2}
mensuales <- empleados %>%          # Crea un nuevo dataframe con los datos de empleados
  select(ID, AREA, PUESTO, SUELDO)  # Selecciona las variables de inter칠s
```

### Pregunta

Varias funciones de `dplyr` tienen algunas variantes auxiliares. 쯇or ejemplo, qu칠 cre칠s que hace el siguiente c칩digo?

```{r qselect, echo=TRUE, eval=FALSE}
plantel %>% 
  select_if(is.numeric)
```

```{r qselect1}
quiz(question("쯈u칠 har치 la funci칩n select_if(is.numeric)?",
         answer("Selecciona las columnas si son num칠ricas", 
                correct = TRUE, 
                message = "Perfecto, select_if(is.numeric) seleccionar치 todas las columnas num칠ricas"),
         answer("Selecciona las columnas si no son num칠ricas",
                message = "Incorrecto, todo lo contrario"),
         answer("No es una funci칩n real",
                message = "Incorrecto, es una funci칩n real, y en algunos casos muy pr치ctica"),
         submit_button = "Enviar respuesta",
         try_again_button = "Intenta de nuevo",
         allow_retry = TRUE)
         )
```

## filter()

La funci칩n `select()` elige columnas, `filter()` por otro lado, nos permite seleccionar filas que coincidan con un criterio de filtro para determinar qu칠 casos pasan cu치les no lo hacen.

Para trabajar con filter vamos a necesitar algunos *operadores l칩gicos*:

```{r filter}
library(gt)
gt(
  data.frame(
    "S칤mbolo" = c("<", "<=", ">", ">=", "==", "!=", "&", "|"),
    "Significado" = c("menor a", "menor o igual a", "mayor a", "mayor o igual a",
                "igual a", "distinto a", "y (and)", "o (or)")
  )
) %>% 
  cols_align(
    align = "center",
    columns = everything()
  )
```

Hay que prestar mucha atenci칩n cuando decimos coloquialmente por ejemplo *"filtrar 치rea igual a RRHH"* porque el s칤mbolo que hay que usar es `==` y no `=`. 쯇or qu칠?

-   九덢잺`AREA == "RRHH"` va a filtrar todas las filas de la columna *AREA* que digan *RRHH*.

-   仇`AREA = "RRHH"` va a crear un objeto en la memoria que se llamar치 *AREA* y cuyo valor ser치 *RRHH*

En mi opini칩n, es tambi칠n un punto a favor del uso de la *"flechita"* (`<-`) para crear objetos, ya que el signo igual lo usamos para modificar par치metros dentro de las funciones.

Entonces, 쯖칩mo hago para seleccionar a las personas del `AREA` de `FINANZAS`?

```{r sel1, exercise=TRUE, exercise.lines=6}
# Primero indico el nombre del dataframe
empleados %>% 
# Luego ejecuto el filtro  
  filter(AREA __ "FINANZAS")
```

```{r sel1-hint}
# Revisa la tabla de operadores l칩gicos de m치s arriba
# 쮺u치ntos s칤mbolos 'igual' (=) necesit치s? 1 o 2?
```

```{r sel1-solution}
# Primero indico el nombre del dataframe
empleados %>% 
# Luego ejecuto el filtro  
  filter(AREA == "FINANZAS")
```

Es importante que cuando estemos filtrando una variable categ칩rica usemos las comillas para nombrar la condici칩n por la que queremos filtrar los datos.

El signo de exclamaci칩n (`!`) sirve en R como un operador de negaci칩n. Por ejemplo, si escribimos:

```{r sel-ejemplo, echo=TRUE, eval=FALSE}
empleados %>% 
  filter(AREA != "RRHH")
```

Lo que obtendremos ser치n todos los empleados que **no sean de RRHH**.

Un error frecuente que cometemos cuando estamos aprendiendo sobre `tidyverse` es usar la funci칩n `filter()` con un s칩lo signo igual. Probemos correr la siguiente l칤nea de c칩digo:

## group_by() y summarise()

## mutate()
