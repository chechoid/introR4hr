---
title: "Sesi칩n 1 - Introducci칩n a R y Tidyverse"
output: 
  learnr::tutorial:
  theme: spacelab
runtime: shiny_prerendered
description: "Tutorial de la Clase 1 del Curso Introducci칩n a R para RRHH"
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)

# Datasets
library(openxlsx)
library(tidyverse)

#carpeta <- "inst/tutorials/sesion1/"

plantel <- read.xlsx("plantel.xlsx")
salarios <- read.xlsx("puestos.xlsx")

empleados <- left_join(plantel, salarios, by = "ID")

mensualizados <- plantel %>% 
  left_join(salarios, by ="ID") %>% 
  filter(!is.na(PUESTO))

encuesta <- read.csv("https://raw.githubusercontent.com/r4hr/kiwi2020/main/rh_ar.csv",
                     sep = ";")
```

## Sesi칩n 1 - Introducci칩n a Tidyverse

![Estados de 치nimo de lxs programadores](images/mood_coder.png)

Este tutorial corresponde a la clase de **Introducci칩n a la limpieza de datos con Tidyverse** del  curso Introducci칩n a R para RRHH de [Data 4HR](https://data-4hr.com/capacitacion/curso-introduccion-r-para-rrhh/). 

Con este tutorial vas a poder practicar algunas de las funciones de `tidyverse`, una colecci칩n de paquetes dise침adas para *"domar datos"*: limpiar, filtrar, seleccionar, y transformas los datos para que se ajusten a nuestras necesidades de an치lisis.

Record치 que cont치s con los siguientes canales de comunicaci칩n para hacer consultas:


游뱋 [Slack](https://join.slack.com/t/r4hr/shared_invite/zt-ocriyx5e-nqXuwWeDyOKm2ICUJjhu6g)

游니 [Discord](https://discord.gg/3xhNH6kRad)

En Slack tenemos un canal llamado **#auxilio** donde pod칠s hacer todas las consultas que quieras.

Muchas gracias!

**Sergio Garcia Mora | Data 4HR**


![](https://i.creativecommons.org/l/by-nc/4.0/88x31.png)


**Sergio Garcia Mora** **Data 4HR**


## Proyectos

Los proyectos son una de las grandes ventajas de trabajar con RStudio. Internamente crea carpetas dentro de *Mis documentos* (o la carpeta que elijas) haciendo que tu c칩digo y los datos est칠n almacenados organizadamente, redireccionando las carpetas de trabajo cada vez que cambias de proyecto.

Para crear un proyecto primero hay que entrar en *File -\> New Project* y se abrir치 una ventana como la siguiente:

![](images/new_project.png){width="348"}

Elegimos la opci칩n *New Directory* en la ventana siguiente volvemos a hacer click en *New Project* y luego en la siguiente ventana, podemos elegir el nombre del proyecto, elegir la carpeta en la que queremos guardarlo con el bot칩n *Browse*.

![](images/new_projecto.png)

Arriba a la derecha, debajo del 칤cono para cerrar el programa RStudio va a aparecer un 칤cono de un cubo celeste con el nombre del proyecto que acabamos de crear. Desde el men칰 desplegable podemos intercambiar de proyectos cada vez que lo necesitemos.

## Repaso: Objetos

R es un lenguaje orientado a objetos. Esto quiere decir que las tablas, valores y resultados, les podemos dar un nombre, y utilizar ese nombre para que sea m치s f치cil operar y programar los scripts.

> Recomendaci칩n: Pon칠 nombres claros y descriptivos a los objetos, que sean breves, pero a su vez que den una pista sobre lo que contiene. Record치 que ac치 lo m치s importante no es que R entienda lo que est치s haciendo, sino que lo pueda entender otra persona, e incluso vos mismo cuando vuelvas a leer tu propio script dentro de 6 meses o un a침o.

Algo interesante con los objetos es que podemos utilizarlos y operar con ellos en los scripts.

Para crear un objeto podemos usar el s칤mbolo `<-` (la *"flechita"*), o bien el signo igual `=`. En R preferimos usar la *flechita* como asignador porque el signo igual se usa mucho en la modificaci칩n de par치metros de funciones.

### Ejercicio

El costo de la rotaci칩n seg칰n el [Dr. Jac Fitz-enz](https://www.linkedin.com/in/dr-jac-fitzenz-89782a55/), el padre de la rotaci칩n en RRHH es de 6 sueldos para personas de convenio o semi seniors, o hasta **un sueldo anual** en el caso de managers o profesionales.

Es decir que la forma de calcular el costo de la rotaci칩n anual, asumiendo que  estamos haciendo un c치lculo conservador (6 meses) es:

$ Sueldo Promedio x 6 x Cantidad Bajas $

As칤 con las siguientes presunciones vamos a calcular el costo de rotaci칩n de tu organizaci칩n.

* Crea un objeto que se llame `sueldo_referencia` cuyo monto sea de USD 1.000.
* Crea un objeto llamado `bajas` con la cantidad de personas desvinculadas. Tom치 el n칰mero de egresos de la compa침칤a en la que trabajas en los 칰ltimos 12 meses, o simplemente inventa un n칰mero cualquiera.

Usa los objetos para calcular el costo de rotaci칩n.


```{r objeto, exercise = TRUE, exercise.lines = 9}
# Crea los valores de referencia
sueldo_referencia <- 1000
bajas ___ ______

# Calcular el costo de rotaci칩n multiplicando ambos objetos por 6
costo_rotacion <- sueldo_referencia * ___ * _______

# Ver el resultado
costo_rotacion
```

```{r objeto-hint-1}
# Asigna el elemento 'bajas' un valor cualquiera. Por ejemplo, las desvinculaciones en tu empresa en los 칰ltimos 12 meses 
# Para calcular el costo de rotaci칩n multiplica sueldo_referencia * 6 * bajas
```

```{r objeto-hint-2}
# Crea los valores de referencia
sueldo_referencia <- 1000
bajas <- 18

# Calcular el costo de rotaci칩n multiplicando ambos objetos por 6
costo_rotacion <- sueldo_referencia * 6 * bajas

# Ver el resultado
costo_rotacion
```


## Repaso: Vectores

Los vectores son conjuntos de datos. Los creamos con una funci칩n llamada `c()` que significa *combine* (combinar).

Por ejemplo:

```{r vec-ej1}
# Vector num칠rico
numeros <- c(16, 8, 42)

# Vector de texto
texto <- c("RH", "People Analytics", "IA")

# Ver sus contenidos
numeros
texto
```

쯈u칠 tipo de vector genera este c칩digo?

```{r vec-ej2, eval=FALSE}
ejercicio <- c("1", 7, 9)
```

```{r vec-quizz}
quiz(
  question("쯈u칠 tipo de vector genera el c칩digo anterior?",
           answer("Num칠rico", message = "Si bien son tres valores num칠ricos, el hecho de que el primero est칠 entre comillas, hace que R lo considere un tipo de dato character o de texto"),
           answer("Texto", correct = TRUE, message = "Correcto! Cuando a un n칰mero lo escribimos entre comillas R lo interpreta como texto"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE
)
)
```

## Paquetes

Los *paquetes* son conjuntos de funciones que desarrolla la comunidad de R y que ampl칤an las capacidades y funcionalidades de R base. Nos permiten hacer m치s cosas y de manera m치s simple.

Los paquetes *se instalan por 칰nica vez* usando la funci칩n `install.packages("nombre_del_paquete")`. Dentro de la funci칩n, se tiene que poner el nombre del paquete, respetando may칰sculas y min칰sculas, y **las comillas** son fundamentales.

Una vez que el paquete est치 instalado, tenemos que *"activarlo"* para poder usar sus funciones. Esto lo hacemos con la funci칩n `library(nombre_del_paquete)`. Si el paquete est치 instalado y est치s usando RStudio, a medida que vayas escribiendo el nombre del paquete te va a aparecer el nombre para autocompletar.

Te das cuenta que el paquete est치 activo porque:

-   Al empezar a escribir las funciones, aparece para autocompletar el nombre de la funci칩n, a qu칠 paquete pertenece, y un cuadro de ayuda.

    ![](images/paquete_activo.png){width="550"}

-   En la pesta침a **Packages** te va a aparecer con una tilde en el nombre del paquete. ![](images/paquete_activo2-01.png)

### Preguntas

En este primer ejercicio tendr치s que corregir el c칩digo para activar el paquete `tidyverse`. 쮺u치l es la funci칩n que ten칠s que usar para lograrlo?

```{r activar-paquete, exercise = TRUE, exercise.lines = 4}
_______(tidyverse)
```

```{r activar-paquete-hint}
# Para instalar o activar un paquete revisa que el nombre no tenga errores de tipeo.
# R es case sensitive, controla que las may칰sculas o min칰sculas est칠n bien.
# Recuerda que no son necesarias las comillas.
library(tidyverse)
```

```{r paquetes}
quiz(
  question("쮺u치ntas veces hay que instalar un paquete?",
           answer("Una sola vez", correct = TRUE),
           answer("Cada vez que corremos un script", message = "La instalaci칩n s칩lo es necesaria una sola vez"),
           answer("Cada vez que creamos un proyecto nuevo", message = "No importa la cantidad de proyectos. Cada vez que instalamos un paquete queda disponible para todos los proyectos que creemos."),
           answer("Depende", message = "[Depende](https://youtu.be/dgf5QlcyTFY) es una bonita canci칩n de Jarabe de Palo y en este caso es una respuesta incorrecta ;p"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE),
  question("Cada vez que abro un script es necesario correr la funci칩n `library`",
           answer("Verdadero", correct = TRUE, message = "Si, es correcto, cada vez que abrimos R tenemos que correr el script desde el principio y vover a activar los paquetes."),
           answer("Falso", message = "Cada vez que abrimos el script hay que correr todo el c칩digo desde el principio y activar el paquete con la funci칩n library"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE),
  question("쯇or qu칠 aparece este mensaje de error?: 'no se pudo encontrar la funci칩n _________'",
  answer("Porque el paquete no est치 instalado", message = "Es posible, pero hay otra respuesta m치s espec칤fica"),
  answer("Porque no corri칩 la funci칩n library()", correct = TRUE, message = "Perfecto! La funci칩n library() activa las funciones"),
  answer("Porque est치 mal escrito el nombre del paquete", message = "Si hay un error de tipeo el mensaje dir칤a: there is no package called ___"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE
))
```

## Tidyverse

![](images/tidyverse_packages.png){width="438"}

Tidyverse es un conjunto de paquetes, dise침ados principalmente para la manipulaci칩n y transformaci칩n de datos. En este primer curso trabajamos mucho con el paquete `dplyr` que nos permite filtrar datos, unir datos de diversas fuentes, y hacer las transformaciones necesarias para poder realizar nuestros an치lisis. Para saber m치s del resto de los paquetes busc치 en el [Google Drive](https://drive.google.com/drive/folders/1Qck3z_t6XLRXb2vbN-00931DgdJZ0yse?usp=sharing) del **Club de R para RRHH** o mir치 los videos en [Youtube](https://youtube.com/playlist?list=PLZuVytUJrxQlcqu6l-P3ou4vV2mRJU2Ka).

## Funciones o verbos de dplyr

Ten칠 a mano el [cheatsheet de data-wrangling](https://drive.google.com/file/d/1ViFJRuby7FTDgjWvp9P6hKO3MEHgeH_M/view?usp=sharing) en castellano. Los cheatsheets (machetes, cola, trencito, torpedo, chuleta, copiat칤n, plage, chanchullo) son ayuda memorias con las principales funciones de un paquete.

Las funciones que vimos en el curso (que no son todas las del paquete) son:

-   **left_join():** Permite unir informaci칩n de varias tablas. Los sistemas de gesti칩n de RRHH tienen por ejemplo una tabla que tiene informaci칩n b치sica de las personas (nombre y apellido, fecha de nacimiento, etc.), otra tabla con la remuneraci칩n base y los conceptos salariales que le correspondan, y podr칤a tener otras tablas con las evaluaciones de desempe침o y as칤 sucesivamente. Hay muchos tipos distintos de `join`, pero a los fines pr치cticos de este curso nos quedaremos con `left_join()` que es una funci칩n equivalente a realizar un *buscarv* o un *vlookup* en Excel.

-   **select():** Permite seleccionar las columnas con las que queremos trabajar. Tambi칠n permite acomodarlas en el orden que las necesitemos, y tambi칠n la podemos usar para descartar variables que no necesitemos.

-   **filter():** Nos permite filtrar las filas que cumplan con una o m치s condiciones. Por ejemplo, si queremos hacer un an치lisis de un grupo espec칤fico de empleados (por ejemplo L칤deres), vamos a filtrar de una tabla de empleados, los empleados que tengan una posici칩n de liderazgo.

-   **group_by():** Por ejemplo, si quiero analizar los sueldos promedios por puesto, un paso previo que tenemos que hacer es *agrupar* los datos por la variable `puesto` antes de calcular el promedio. Es un paso previo que realizaremos siempre antes de hacer alg칰n c치lculo de resumen estad칤stico.

-   **summarise():** Es la funci칩n que nos permite hacer c치lculos de resumen estad칤stico (calcular promedios, medianas, contar filas, desv칤os est치ndares, etc.). Lo

-   **mutate():** Uno de los principales usos de `mutate()` es el de crear una nueva variable (columna) en nuestro dataframe original en base a alguna columna que ya exista. Por ejemplo, si tengo una columna que contenga el sueldo b치sico mensual de un empleado, podr칤a a침adir otra columna que calcule las cargas sociales, o bien el costo anual de cada colaborador/a. Otro uso que se le da es para modificar las caracter칤sticas de una variable (lo veremos en un ejercicio).

## El "pipe" %\>%

Uno de los paquetes de tidyverse, el paquete `dplyr` aporta un s칤mbolo conocido como *"pipe"* `%>%` (*tubo* en ingl칠s). El atajo de teclado es con las teclas *Ctrl +Shift +M* en Windows, o *Cmd + Shift + M* en Mac.

A partir de la versi칩n 4.1.0 de R, hay una versi칩n nativa de R del *pipe* cuyo s칤mbolo es `|>` pero en este curso utilizaremos la versi칩n del paquete `dplyr`.

Lo que nos permite este *pipe* o *tubo* es escribir los c칩digos en secuencias, haciendo much칤simo m치s f치cil escribir y leer secuencias de funciones que incluyan varios pasos.

Imaginemos que queremos comprar regalos por el d칤a del ni침o a todos los empleados de la empresa que tengan hijos. Para esto, necesitamos un listado de los empleados que tengan hijos, ordenados por sector. Para lograr esto los pasos que tenemos que seguir son:

1.  Seleccionar las columnas `AREA`, `ID` e `HIJOS` del dataframe `nomina`.

2.  Filtrar los empleados que tengan hijos (donde en la columna `HIJOS` el valor sea mayor que cero.

3.  Ordenar los resultados por `AREA`.

Veamos c칩mo se ve el c칩digo de R sin el uso del pipe `%>%`:

```{r ej3, echo=TRUE, eval=FALSE}

# Ejemplo de funciones anidadas sin usar el pipe
arrange(filter(select(nomina, AREA,ID, HIJOS), HIJOS > 0), AREA)
```

Ahora veamos el siguiente c칩digo, que logra lo mismo que antes, pero usando el pipe `%>%`

```{r ej4, echo=TRUE, eval=FALSE}
# Ejemplo de funciones anidadas usando el pipe
nomina %>% 
  select(AREA, ID, HIJOS) %>% 
  filter(HIJOS > 0) %>% 
  arrange(AREA)
```

쮺u치l te parece la forma m치s sencilla de entender la secuencia de an치lisis?

## Unir datos con left_join()

Tenemos dos dataframes, uno con informaci칩n general de los empleados. El dataframe `plantel` contiene 8 variables:

-   ID: el dato de identificaci칩n 칰nica de cada persona de la empresa.

-   ANTIGUEDAD: Los a침os de permanencia en la organizaci칩n.

-   EDAD: La edad de los colaboradores.

-   ESTADO_CIVIL: El estado civil de los trabajadores/as de la compa침칤a.

-   HIJOS: La cantidad de hijos que tiene cada colaborador.

-   AREA: El sector en el que trabaja cada persona.

-   ID_CAT: La clave identificatoria de las categor칤as de los trabajadores.

-   N_CATEG: El nombre de cada categor칤a.

Veamos la estructura del dataframe.

```{r str1, exercise = TRUE}
#Correr este c칩digo
str(plantel)
```

El siguiente dataframe, `salarios` contiene los siguientes campos:

-   ID: el campo que nos permitir치 unir las diferentes tablas.

-   PUESTO: el nombre real del puesto que ocupa cada persona.

-   SUELDO: La remuneraci칩n b치sica mensual de cada empleado.

Prest치 atenci칩n a la estructura del archivo y contesta la siguiente pregunta.

```{r str2, exercise = TRUE}
str(salarios)
```

```{r left-q}
quiz(
  question("쮺u치ntas filas y columnas tiene el dataframe 'salarios'?",
  answer("135 columnas y 3 variables", message = "Las observaciones son las filas y las variables son las columnas"),
  answer("130 filas y 10 variables", message = "Mir치 de nuevo el resultado de la estructura del dataframe salarios. Primero indica las observaciones, y luego las variables"),
  answer("135 filas y 3 columnas", correct = TRUE, message = "Muy bien!"),
  submit_button = "Enviar respuesta",
  try_again_button = "Intenta de nuevo",
  allow_retry = TRUE
))
```

Ahora vamos a unir ambos dataframes en uno solo para poder hacer nuestros an치lisis.

Usaremos la funci칩n `left_join()` para agregar al dataframe `plantel` los datos del dataframe `salarios.`

```{r leftjoin, exercise = TRUE, exercise.lines=7}
# Agrega al dataframe 'plantel' el dataframe 'salarios'
empleados <- left____(_____, _____, by = "ID")

# Ver la estructura del nuevo dataframe
___(__________)
```

```{r leftjoin-hint}
# Recuerda poner la funci칩n left_join()
# A침ade al dataframe 'plantel', los datos de 'salarios' por la columna ID
# Cuidado con may칰sculas y min칰sculas
# Para ver la estructura del dataframe usa la funci칩n str(nombre_dataframe)
```

```{r leftjoin-solution}
empleados <- left_join(plantel, salarios, by = "ID")

# Ver la estructura del nuevo dataframe
str(empleados)
```

Hay muchos tipos de `join`, por ejemplo `right_join`, `inner_join`, `anti_join`, `full_join`, que no ser치n parte de este curso.

## select()

Con la funci칩n `select()` podemos elegir las columnas que nos interesa trabajar. Por ejemplo, prueba de correr la funci칩n `str()` con el nuevo dataframe `empleados`.

Esta es una funci칩n particularmente 칰til cuando trabajamos con datasets muy grandes que contienen muchas columnas y filas, que mejora los tiempos de procesamiento de datos.

```{r str, exercise = TRUE, exercise.lines = 5, exercise.setup="fuente"}
# Corre esta l칤nea de c칩digo
str(empleados)
```

Las variables `ANTIGUEDAD`, `EDAD`, `ESTADO_CIVIL` e `HIJOS` no tienen mucho sentido para un an치lisis salarial. En el pr칩ximo ejercicio, selecciona las columnas `ID`, `AREA`, `PUESTO`, `SUELDO` y guarda la selecci칩n en un objeto llamado `mensuales.`

```{r select, exercise = TRUE, exercise.lines = 5, exercise.setup="fuente"}
mensuales <- empleados %>% 
  _______(___, ___, ____, ____)
```

```{r select-hint}
# Usa la funci칩n select()
# Dentro del par칠ntesis pon los nombres de las variables que nos interesa analizar
```

```{r select-solution}
mensuales <- empleados %>%          # Crea un nuevo dataframe con los datos de empleados
  select(ID, AREA, PUESTO, SUELDO)  # Selecciona las variables de inter칠s
```

### Pregunta

Varias funciones de `dplyr` tienen algunas variantes auxiliares. 쯇or ejemplo, qu칠 cre칠s que hace el siguiente c칩digo?

```{r qselect, echo=TRUE, eval=FALSE}
plantel %>% 
  select_if(is.numeric)
```

```{r qselect1}
quiz(question("쯈u칠 har치 la funci칩n select_if(is.numeric)?",
         answer("Selecciona las columnas si son num칠ricas", 
                correct = TRUE, 
                message = "Perfecto, select_if(is.numeric) seleccionar치 todas las columnas num칠ricas"),
         answer("Selecciona las columnas si no son num칠ricas",
                message = "Incorrecto, todo lo contrario"),
         answer("No es una funci칩n real",
                message = "Incorrecto, es una funci칩n real, y en algunos casos muy pr치ctica"),
         submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE)
         )
```

## filter()

La funci칩n `select()` elige columnas, `filter()` por otro lado, nos permite seleccionar filas que coincidan con un criterio de filtro para determinar qu칠 casos pasan cu치les no lo hacen.

Para trabajar con filter vamos a necesitar algunos *operadores l칩gicos*:

```{r filter}
library(gt)
gt(
  data.frame(
    "S칤mbolo" = c("<", "<=", ">", ">=", "==", "!=", "&", "|"),
    "Significado" = c("menor a", "menor o igual a", "mayor a", "mayor o igual a",
                "igual a", "distinto a", "y (and)", "o (or)")
  )
) %>% 
  cols_align(
    align = "center",
    columns = everything()
  )
```

Hay que prestar mucha atenci칩n cuando decimos coloquialmente por ejemplo *"filtrar 치rea igual a RRHH"* porque el s칤mbolo que hay que usar es `==` y no `=`. 쯇or qu칠?

-   九덢잺`AREA == "RRHH"` va a filtrar todas las filas de la columna *AREA* que digan *RRHH*.

-   仇`AREA = "RRHH"` va a crear un objeto en la memoria que se llamar치 *AREA* y cuyo valor ser치 *RRHH*

En mi opini칩n, es tambi칠n un punto a favor del uso de la *"flechita"* (`<-`) para crear objetos, ya que el signo igual lo usamos para modificar par치metros dentro de las funciones.

Entonces, 쯖칩mo hago para seleccionar a las personas del `AREA` de `FINANZAS`?

```{r sel1, exercise=TRUE, exercise.lines=6}
# Primero indico el nombre del dataframe
empleados %>% 
# Luego ejecuto el filtro  
  filter(AREA __ "FINANZAS")
```

```{r sel1-hint}
# Revisa la tabla de operadores l칩gicos de m치s arriba
# 쮺u치ntos s칤mbolos 'igual' (=) necesit치s? 1 o 2?
```

```{r sel1-solution}
# Primero indico el nombre del dataframe
empleados %>% 
# Luego ejecuto el filtro  
  filter(AREA == "FINANZAS")
```

Es importante que cuando estemos filtrando una variable categ칩rica usemos las comillas para nombrar la condici칩n por la que queremos filtrar los datos.

El signo de exclamaci칩n (`!`) sirve en R como un operador de negaci칩n. Por ejemplo, si escribimos:

```{r sel-ejemplo, echo=TRUE, eval=FALSE}
empleados %>% 
  filter(AREA != "RRHH")
```

Lo que obtendremos ser치n todos los empleados que **no sean de RRHH**.

## group_by() y summarise()

## mutate()
