---
title: "Sesi√≥n 1 - Introducci√≥n a R y Tidyverse"
output: 
  learnr::tutorial:
  theme: spacelab
runtime: shiny_prerendered
description: "Tutorial de la Clase 1 del Curso Introducci√≥n a R para RRHH"
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)

# Datasets
library(openxlsx)
library(tidyverse)

#carpeta <- "inst/tutorials/sesion1/"

plantel <- read.xlsx("plantel.xlsx")
salarios <- read.xlsx("puestos.xlsx")

empleados <- left_join(plantel, salarios, by = "ID")

mensualizados <- plantel %>% 
  left_join(salarios, by ="ID") %>% 
  filter(!is.na(PUESTO))
```

## Curso Introducci√≥n a R para RRHH

Este es un tutorial sobre la primera clase del curso **Introducci√≥n a R para RRHH** de [Data 4HR](https://data-4hr.com/capacitacion/curso-introduccion-r-para-rrhh/). El objetivo de este tutorial y sus preguntas es ayudar a comprender y fijar algunos conceptos de la clase 1.

Este tutorial no ser√≠a posible sin la comunidad latinoamericana de R, por eso este primer m√≥dulo lo pueden compartir y utilizar citando a Data 4HR, y sin fines comerciales.

![](https://i.creativecommons.org/l/by-nc/4.0/88x31.png)

Para contactarme, pod√©s escribirme a [sergio\@d4hr.com](mailto:sergio@d4hr.com), visitar la web de [Data 4HR](https://data-4hr.com) o buscarme en redes sociales:

üë®‚Äçüíº [LinkedIn](https://www.linkedin.com/in/sergiogarciamora/)

‚öîÔ∏è [Twitter](https://twitter.com/sergiogarciamor)

üì± [Telegram](http://t.me/SergioGarciaMora)

üì° [Discord](https://discord.gg/3xhNH6kRad)

ü§ù [Slack](https://join.slack.com/t/r4hr/shared_invite/zt-ocriyx5e-nqXuwWeDyOKm2ICUJjhu6g)

Muchas gracias!

**Sergio Garcia Mora** **Data 4HR**


### Proyectos

Los proyectos son una de las grandes ventajas de trabajar con RStudio. Internamente crea carpetas dentro de *Mis documentos* (o la carpeta que elijas) haciendo que tu c√≥digo y los datos est√©n almacenados organizadamente, redireccionando las carpetas de trabajo cada vez que cambias de proyecto.

Para crear un proyecto primero hay que entrar en *File -\> New Project* y se abrir√° una ventana como la siguiente:

![](images/new_project.png){width="348"}

Elegimos la opci√≥n *New Directory* en la ventana siguiente volvemos a hacer click en *New Project* y luego en la siguiente ventana, podemos elegir el nombre del proyecto, elegir la carpeta en la que queremos guardarlo con el bot√≥n *Browse*.

![](images/new_projecto.png)

Arriba a la derecha, debajo del √≠cono para cerrar el programa RStudio va a aparecer un √≠cono de un cubo celeste con el nombre del proyecto que acabamos de crear. Desde el men√∫ desplegable podemos intercambiar de proyectos cada vez que lo necesitemos.

## Repaso: Objetos

R es un lenguaje orientado a objetos. Esto quiere decir que las tablas, valores y resultados, les podemos dar un nombre, y utilizar ese nombre para que sea m√°s f√°cil operar y programar los scripts.

> Recomendaci√≥n: Pon√© nombres claros y descriptivos a los objetos, que sean breves, pero a su vez que den una pista sobre lo que contiene. Record√° que ac√° lo m√°s importante no es que R entienda lo que est√°s haciendo, sino que lo pueda entender otra persona, e incluso vos mismo cuando vuelvas a leer tu propio script dentro de 6 meses o un a√±o.

Algo interesante con los objetos es que podemos utilizarlos y operar con ellos en los scripts.

Para crear un objeto podemos usar el s√≠mbolo `<-` (la *"flechita"*), o bien el signo igual `=` .

### Ejercicio

Asigna al objeto `anio_nacimiento` tu a√±o de nacimiento. Luego usa el objeto para calcular tu edad, y guardarlo en un objeto llamado `edad` .

```{r objeto, exercise = TRUE, exercise.lines = 8}
anio.nacimiento <- ____
anio.actual <- 2021

edad <- anio._____ - anio.________

edad
```

```{r objeto-hint-1}
# Pon√© el a√±o en el que naciste en anio.nacimiento
# Para calcular el objeto edad ten√©s que restar al a√±o actual, tu a√±o de nacimiento
```

```{r objeto-hint-2}
anio.nacimiento <- 1979
anio.actual <- 2021

edad = anio.actual - anio.nacimiento

edad
```


## Paquetes

Los *paquetes* son conjuntos de funciones que desarrolla la comunidad de R y que ampl√≠an las capacidades y funcionalidades de R base. Nos permiten hacer m√°s cosas y de manera m√°s simple.

Los paquetes *se instalan por √∫nica vez* usando la funci√≥n `install.packages("nombre_del_paquete")`. Dentro de la funci√≥n, se tiene que poner el nombre del paquete, respetando may√∫sculas y min√∫sculas, y **las comillas** son fundamentales.

Una vez que el paquete est√° instalado, tenemos que *"activarlo"* para poder usar sus funciones. Esto lo hacemos con la funci√≥n `library(nombre_del_paquete)`. Si el paquete est√° instalado y est√°s usando RStudio, a medida que vayas escribiendo el nombre del paquete te va a aparecer el nombre para autocompletar.

Te das cuenta que el paquete est√° activo porque:

-   Al empezar a escribir las funciones, aparece para autocompletar el nombre de la funci√≥n, a qu√© paquete pertenece, y un cuadro de ayuda.

    ![](images/paquete_activo.png){width="550"}

-   En la pesta√±a **Packages** te va a aparecer con una tilde en el nombre del paquete. ![](images/paquete_activo2-01.png)

### Preguntas

En este primer ejercicio tendr√°s que corregir el c√≥digo para activar el paquete `tidyverse`. ¬øCu√°l es la funci√≥n que ten√©s que usar para lograrlo?

```{r activar-paquete, exercise = TRUE, exercise.lines = 4}
_______(tidyverse)
```

```{r activar-paquete-hint}
# Para instalar o activar un paquete revisa que el nombre no tenga errores de tipeo.
# R es case sensitive, controla que las may√∫sculas o min√∫sculas est√©n bien.
# Recuerda que no son necesarias las comillas.
library(tidyverse)
```

```{r paquetes}
quiz(
  question("¬øCu√°ntas veces hay que instalar un paquete?",
           answer("Una sola vez", correct = TRUE),
           answer("Cada vez que corremos un script", message = "La instalaci√≥n s√≥lo es necesaria una sola vez"),
           answer("Cada vez que creamos un proyecto nuevo", message = "No importa la cantidad de proyectos. Cada vez que instalamos un paquete queda disponible para todos los proyectos que creemos."),
           answer("Depende", message = "[Depende](https://youtu.be/dgf5QlcyTFY) es una bonita canci√≥n de Jarabe de Palo y en este caso es una respuesta incorrecta ;p"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE),
  question("Cada vez que abro un script es necesario correr la funci√≥n `library`",
           answer("Verdadero", correct = TRUE, message = "Si, es correcto, cada vez que abrimos R tenemos que correr el script desde el principio y vover a activar los paquetes."),
           answer("Falso", message = "Cada vez que abrimos el script hay que correr todo el c√≥digo desde el principio y activar el paquete con la funci√≥n library"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE),
  question("¬øPor qu√© aparece este mensaje de error?: 'no se pudo encontrar la funci√≥n _________'",
  answer("Porque el paquete no est√° instalado", message = "Es posible, pero hay otra respuesta m√°s espec√≠fica"),
  answer("Porque no corri√≥ la funci√≥n library()", correct = TRUE, message = "Perfecto! La funci√≥n library() activa las funciones"),
  answer("Porque est√° mal escrito el nombre del paquete", message = "Si hay un error de tipeo el mensaje dir√≠a: there is no package called ___"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE
))
```

## Tidyverse

![](images/tidyverse_packages.png){width="438"}

Tidyverse es un conjunto de paquetes, dise√±ados principalmente para la manipulaci√≥n y transformaci√≥n de datos. En este primer curso trabajamos mucho con el paquete `dplyr` que nos permite filtrar datos, unir datos de diversas fuentes, y hacer las transformaciones necesarias para poder realizar nuestros an√°lisis. Para saber m√°s del resto de los paquetes busc√° en el [Google Drive](https://drive.google.com/drive/folders/1Qck3z_t6XLRXb2vbN-00931DgdJZ0yse?usp=sharing) del **Club de R para RRHH** o mir√° los videos en [Youtube](https://youtube.com/playlist?list=PLZuVytUJrxQlcqu6l-P3ou4vV2mRJU2Ka).

## Funciones o verbos de dplyr

Ten√© a mano el [cheatsheet de data-wrangling](https://drive.google.com/file/d/1ViFJRuby7FTDgjWvp9P6hKO3MEHgeH_M/view?usp=sharing) en castellano. Los cheatsheets (machetes, cola, trencito, torpedo, chuleta, copiat√≠n, plage, chanchullo) son ayuda memorias con las principales funciones de un paquete.

Las funciones que vimos en el curso (que no son todas las del paquete) son:

-   **left_join():** Permite unir informaci√≥n de varias tablas. Los sistemas de gesti√≥n de RRHH tienen por ejemplo una tabla que tiene informaci√≥n b√°sica de las personas (nombre y apellido, fecha de nacimiento, etc.), otra tabla con la remuneraci√≥n base y los conceptos salariales que le correspondan, y podr√≠a tener otras tablas con las evaluaciones de desempe√±o y as√≠ sucesivamente. Hay muchos tipos distintos de `join`, pero a los fines pr√°cticos de este curso nos quedaremos con `left_join()` que es una funci√≥n equivalente a realizar un *buscarv* o un *vlookup* en Excel.

-   **select():** Permite seleccionar las columnas con las que queremos trabajar. Tambi√©n permite acomodarlas en el orden que las necesitemos, y tambi√©n la podemos usar para descartar variables que no necesitemos.

-   **filter():** Nos permite filtrar las filas que cumplan con una o m√°s condiciones. Por ejemplo, si queremos hacer un an√°lisis de un grupo espec√≠fico de empleados (por ejemplo L√≠deres), vamos a filtrar de una tabla de empleados, los empleados que tengan una posici√≥n de liderazgo.

-   **group_by():** Por ejemplo, si quiero analizar los sueldos promedios por puesto, un paso previo que tenemos que hacer es *agrupar* los datos por la variable `puesto` antes de calcular el promedio. Es un paso previo que realizaremos siempre antes de hacer alg√∫n c√°lculo de resumen estad√≠stico.

-   **summarise():** Es la funci√≥n que nos permite hacer c√°lculos de resumen estad√≠stico (calcular promedios, medianas, contar filas, desv√≠os est√°ndares, etc.). Lo

-   **mutate():** Uno de los principales usos de `mutate()` es el de crear una nueva variable (columna) en nuestro dataframe original en base a alguna columna que ya exista. Por ejemplo, si tengo una columna que contenga el sueldo b√°sico mensual de un empleado, podr√≠a a√±adir otra columna que calcule las cargas sociales, o bien el costo anual de cada colaborador/a. Otro uso que se le da es para modificar las caracter√≠sticas de una variable (lo veremos en un ejercicio).

## El "pipe" %\>%

Uno de los paquetes de tidyverse, el paquete `dplyr` aporta un s√≠mbolo conocido como *"pipe"* `%>%` (*tubo* en ingl√©s). El atajo de teclado es con las teclas *Ctrl +Shift +M* en Windows, o *Cmd + Shift + M* en Mac.

A partir de la versi√≥n 4.1.0 de R, hay una versi√≥n nativa de R del *pipe* cuyo s√≠mbolo es `|>` pero en este curso utilizaremos la versi√≥n del paquete `dplyr`.

Lo que nos permite este *pipe* o *tubo* es escribir los c√≥digos en secuencias, haciendo much√≠simo m√°s f√°cil escribir y leer secuencias de funciones que incluyan varios pasos.

Imaginemos que queremos comprar regalos por el d√≠a del ni√±o a todos los empleados de la empresa que tengan hijos. Para esto, necesitamos un listado de los empleados que tengan hijos, ordenados por sector. Para lograr esto los pasos que tenemos que seguir son:

1.  Seleccionar las columnas `AREA`, `ID` e `HIJOS` del dataframe `nomina`.

2.  Filtrar los empleados que tengan hijos (donde en la columna `HIJOS` el valor sea mayor que cero.

3.  Ordenar los resultados por `AREA`.

Veamos c√≥mo se ve el c√≥digo de R sin el uso del pipe `%>%`:

```{r ej3, echo=TRUE, eval=FALSE}

# Ejemplo de funciones anidadas sin usar el pipe
arrange(filter(select(nomina, AREA,ID, HIJOS), HIJOS > 0), AREA)
```

Ahora veamos el siguiente c√≥digo, que logra lo mismo que antes, pero usando el pipe `%>%`

```{r ej4, echo=TRUE, eval=FALSE}
# Ejemplo de funciones anidadas usando el pipe
nomina %>% 
  select(AREA, ID, HIJOS) %>% 
  filter(HIJOS > 0) %>% 
  arrange(AREA)
```

¬øCu√°l te parece la forma m√°s sencilla de entender la secuencia de an√°lisis?

## Unir datos con left_join()

Tenemos dos dataframes, uno con informaci√≥n general de los empleados. El dataframe `plantel` contiene 8 variables:

-   ID: el dato de identificaci√≥n √∫nica de cada persona de la empresa.

-   ANTIGUEDAD: Los a√±os de permanencia en la organizaci√≥n.

-   EDAD: La edad de los colaboradores.

-   ESTADO_CIVIL: El estado civil de los trabajadores/as de la compa√±√≠a.

-   HIJOS: La cantidad de hijos que tiene cada colaborador.

-   AREA: El sector en el que trabaja cada persona.

-   ID_CAT: La clave identificatoria de las categor√≠as de los trabajadores.

-   N_CATEG: El nombre de cada categor√≠a.

Veamos la estructura del dataframe.

```{r str1, exercise = TRUE}
#Correr este c√≥digo
str(plantel)
```

El siguiente dataframe, `salarios` contiene los siguientes campos:

-   ID: el campo que nos permitir√° unir las diferentes tablas.

-   PUESTO: el nombre real del puesto que ocupa cada persona.

-   SUELDO: La remuneraci√≥n b√°sica mensual de cada empleado.

Prest√° atenci√≥n a la estructura del archivo y contesta la siguiente pregunta.

```{r str2, exercise = TRUE}
str(salarios)
```

```{r left-q}
quiz(
  question("¬øCu√°ntas filas y columnas tiene el dataframe 'salarios'?",
  answer("135 columnas y 3 variables", message = "Las observaciones son las filas y las variables son las columnas"),
  answer("130 filas y 10 variables", message = "Mir√° de nuevo el resultado de la estructura del dataframe salarios. Primero indica las observaciones, y luego las variables"),
  answer("135 filas y 3 columnas", correct = TRUE, message = "Muy bien!"),
  submit_button = "Enviar respuesta",
  try_again_button = "Intenta de nuevo",
  allow_retry = TRUE
))
```

Ahora vamos a unir ambos dataframes en uno solo para poder hacer nuestros an√°lisis.

Usaremos la funci√≥n `left_join()` para agregar al dataframe `plantel` los datos del dataframe `salarios.`

```{r leftjoin, exercise = TRUE, exercise.lines=7}
# Agrega al dataframe 'plantel' el dataframe 'salarios'
empleados <- left____(_____, _____, by = "ID")

# Ver la estructura del nuevo dataframe
___(__________)
```

```{r leftjoin-hint}
# Recuerda poner la funci√≥n left_join()
# A√±ade al dataframe 'plantel', los datos de 'salarios' por la columna ID
# Cuidado con may√∫sculas y min√∫sculas
# Para ver la estructura del dataframe usa la funci√≥n str(nombre_dataframe)
```

```{r leftjoin-solution}
empleados <- left_join(plantel, salarios, by = "ID")

# Ver la estructura del nuevo dataframe
str(empleados)
```

Hay muchos tipos de `join`, por ejemplo `right_join`, `inner_join`, `anti_join`, `full_join`, que no ser√°n parte de este curso.

## select()

Con la funci√≥n `select()` podemos elegir las columnas que nos interesa trabajar. Por ejemplo, prueba de correr la funci√≥n `str()` con el nuevo dataframe `empleados`.

Esta es una funci√≥n particularmente √∫til cuando trabajamos con datasets muy grandes que contienen muchas columnas y filas, que mejora los tiempos de procesamiento de datos.

```{r str, exercise = TRUE, exercise.lines = 5, exercise.setup="fuente"}
# Corre esta l√≠nea de c√≥digo
str(empleados)
```

Las variables `ANTIGUEDAD`, `EDAD`, `ESTADO_CIVIL` e `HIJOS` no tienen mucho sentido para un an√°lisis salarial. En el pr√≥ximo ejercicio, selecciona las columnas `ID`, `AREA`, `PUESTO`, `SUELDO` y guarda la selecci√≥n en un objeto llamado `mensuales.`

```{r select, exercise = TRUE, exercise.lines = 5, exercise.setup="fuente"}
mensuales <- empleados %>% 
  _______(___, ___, ____, ____)
```

```{r select-hint}
# Usa la funci√≥n select()
# Dentro del par√©ntesis pon los nombres de las variables que nos interesa analizar
```

```{r select-solution}
mensuales <- empleados %>%          # Crea un nuevo dataframe con los datos de empleados
  select(ID, AREA, PUESTO, SUELDO)  # Selecciona las variables de inter√©s
```

### Pregunta

Varias funciones de `dplyr` tienen algunas variantes auxiliares. ¬øPor ejemplo, qu√© cre√©s que hace el siguiente c√≥digo?

```{r qselect, echo=TRUE, eval=FALSE}
plantel %>% 
  select_if(is.numeric)
```

```{r qselect1}
question("¬øQu√© har√° la funci√≥n select_if(is.numeric)?",
         answer("Selecciona las columnas si son num√©ricas", 
                correct = TRUE, 
                message = "Perfecto, select_if(is.numeric) seleccionar√° todas las columnas num√©ricas"),
         answer("Selecciona las columnas si no son num√©ricas",
                message = "Incorrecto, todo lo contrario"),
         answer("No es una funci√≥n real",
                message = "Incorrecto, es una funci√≥n real, y en algunos casos muy pr√°ctica"),
         submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE)
         )
```

## filter()

La funci√≥n `select()` elige columnas, `filter()` por otro lado, nos permite seleccionar filas que coincidan con un criterio de filtro para determinar qu√© casos pasan cu√°les no lo hacen.

Para trabajar con filter vamos a necesitar algunos *operadores l√≥gicos*:

```{r filter}
library(gt)
gt(
  data.frame(
    "S√≠mbolo" = c("<", "<=", ">", ">=", "==", "!=", "&", "|"),
    "Significado" = c("menor a", "menor o igual a", "mayor a", "mayor o igual a",
                "igual a", "distinto a", "y (and)", "o (or)")
  )
) %>% 
  cols_align(
    align = "center",
    columns = everything()
  )
```

Hay que prestar mucha atenci√≥n cuando decimos coloquialmente por ejemplo *"filtrar √°rea igual a RRHH"* porque el s√≠mbolo que hay que usar es `==` y no `=`. ¬øPor qu√©?

-   ‚úîÔ∏è`AREA == "RRHH"` va a filtrar todas las filas de la columna *AREA* que digan *RRHH*.

-   ‚ùå`AREA = "RRHH"` va a crear un objeto en la memoria que se llamar√° *AREA* y cuyo valor ser√° *RRHH*

En mi opini√≥n, es tambi√©n un punto a favor del uso de la *"flechita"* (`<-`) para crear objetos, ya que el signo igual lo usamos para modificar par√°metros dentro de las funciones.

Entonces, ¬øc√≥mo hago para seleccionar a las personas del `AREA` de `FINANZAS`?

```{r sel1, exercise=TRUE, exercise.lines=6}
# Primero indico el nombre del dataframe
empleados %>% 
# Luego ejecuto el filtro  
  filter(AREA __ "FINANZAS")
```

```{r sel1-hint}
# Revisa la tabla de operadores l√≥gicos de m√°s arriba
# ¬øCu√°ntos s√≠mbolos 'igual' (=) necesit√°s? ¬ø1 o 2?
```

```{r sel1-solution}
# Primero indico el nombre del dataframe
empleados %>% 
# Luego ejecuto el filtro  
  filter(AREA == "FINANZAS")
```

Es importante que cuando estemos filtrando una variable categ√≥rica usemos las comillas para nombrar la condici√≥n por la que queremos filtrar los datos.

El signo de exclamaci√≥n (`!`) sirve en R como un operador de negaci√≥n. Por ejemplo, si escribimos:

```{r sel-ejemplo, echo=TRUE, eval=FALSE}
empleados %>% 
  filter(AREA != "RRHH")
```

Lo que obtendremos ser√°n todos los empleados que **no sean de RRHH**.

## group_by() y summarise()

## mutate()
