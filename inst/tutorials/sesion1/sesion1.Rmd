---
title: "Sesi√≥n 1 - Introducci√≥n a R y Tidyverse"
output: 
  learnr::tutorial:
  theme: spacelab
runtime: shiny_prerendered
description: "Tutorial de la Clase 1 del Curso Introducci√≥n a R para RRHH"
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)

# Datasets
library(openxlsx)
library(tidyverse)

#carpeta <- "inst/tutorials/sesion1/"

plantel <- read.xlsx("plantel.xlsx")
salarios <- read.xlsx("puestos.xlsx")

empleados <- left_join(plantel, salarios, by = "ID")

mensuales <- plantel %>% 
  left_join(salarios, by ="ID") %>% 
  filter(!is.na(PUESTO))

encuesta <- read.csv("https://raw.githubusercontent.com/r4hr/kiwi2020/main/rh_ar.csv",
                     sep = ";",
                     encoding = "UTF-8")
```

## Sesi√≥n 1 - Introducci√≥n a Tidyverse

![Estados de √°nimo de lxs programadores](images/mood_coder.png){width="40%"}

Este tutorial corresponde a la clase de **Introducci√≥n a la limpieza de datos con Tidyverse** del curso Introducci√≥n a R para RRHH de [Data 4HR](https://data-4hr.com/capacitacion/curso-introduccion-r-para-rrhh/).

Con este tutorial vas a poder practicar algunas de las funciones de `tidyverse`, una colecci√≥n de paquetes dise√±adas para *"domar datos"*: limpiar, filtrar, seleccionar, y transformas los datos para que se ajusten a nuestras necesidades de an√°lisis.

Record√° que cont√°s con los siguientes canales de comunicaci√≥n para hacer consultas:

ü§ù [Slack](https://join.slack.com/t/r4hr/shared_invite/zt-ocriyx5e-nqXuwWeDyOKm2ICUJjhu6g)

üì° [Discord](https://discord.gg/3xhNH6kRad)

En Slack tenemos un canal llamado **#auxilio** donde pod√©s hacer todas las consultas que quieras.

Muchas gracias!

**Sergio Garcia Mora \| Data 4HR**

![](https://i.creativecommons.org/l/by-nc/4.0/88x31.png)

**Sergio Garcia Mora** **Data 4HR**

## Proyectos

Los proyectos son una de las grandes ventajas de trabajar con RStudio. Internamente crea carpetas dentro de *Mis documentos* (o la carpeta que elijas) haciendo que tu c√≥digo y los datos est√©n almacenados organizadamente, redireccionando las carpetas de trabajo cada vez que cambias de proyecto.

Para crear un proyecto primero hay que entrar en *File -> New Project* y se abrir√° una ventana como la siguiente:

![](images/new_project.png){width="348"}

Elegimos la opci√≥n *New Directory* en la ventana siguiente volvemos a hacer click en *New Project* y luego en la siguiente ventana, podemos elegir el nombre del proyecto, elegir la carpeta en la que queremos guardarlo con el bot√≥n *Browse*.

![](images/new_projecto.png)

Arriba a la derecha, debajo del √≠cono para cerrar el programa RStudio va a aparecer un √≠cono de un cubo celeste con el nombre del proyecto que acabamos de crear. Desde el men√∫ desplegable podemos intercambiar de proyectos cada vez que lo necesitemos.

## Repaso: Objetos

R es un lenguaje orientado a objetos. Esto quiere decir que las tablas, valores y resultados, les podemos dar un nombre, y utilizar ese nombre para que sea m√°s f√°cil operar y programar los scripts.

> Recomendaci√≥n: Pon√© nombres claros y descriptivos a los objetos, que sean breves, pero a su vez que den una pista sobre lo que contiene. Record√° que ac√° lo m√°s importante no es que R entienda lo que est√°s haciendo, sino que lo pueda entender otra persona, e incluso vos mismo cuando vuelvas a leer tu propio script dentro de 6 meses o un a√±o.

Algo interesante con los objetos es que podemos utilizarlos y operar con ellos en los scripts.

Para crear un objeto podemos usar el s√≠mbolo `<-` (la *"flechita"*), o bien el signo igual `=`. En R preferimos usar la *flechita* como asignador porque el signo igual se usa mucho en la modificaci√≥n de par√°metros de funciones.

### Ejercicio

El costo de la rotaci√≥n seg√∫n el [Dr. Jac Fitz-enz](https://www.linkedin.com/in/dr-jac-fitzenz-89782a55/), el padre de la rotaci√≥n en RRHH es de 6 sueldos para personas de convenio o semi seniors, o hasta **un sueldo anual** en el caso de managers o profesionales.

Es decir que la forma de calcular el costo de la rotaci√≥n anual, asumiendo que estamos haciendo un c√°lculo conservador (6 meses) es:

\$ Sueldo Promedio x 6 x Cantidad Bajas \$

As√≠ con las siguientes presunciones vamos a calcular el costo de rotaci√≥n de tu organizaci√≥n.

-   Crea un objeto que se llame `sueldo_referencia` cuyo monto sea de USD 1.000.
-   Crea un objeto llamado `bajas` con la cantidad de personas desvinculadas. Tom√° el n√∫mero de egresos de la compa√±√≠a en la que trabajas en los √∫ltimos 12 meses, o simplemente inventa un n√∫mero cualquiera.

Usa los objetos para calcular el costo de rotaci√≥n.

```{r objeto, exercise = TRUE, exercise.lines = 9}
# Crea los valores de referencia
sueldo_referencia <- 1000
bajas ___ ______

# Calcular el costo de rotaci√≥n multiplicando ambos objetos por 6
costo_rotacion <- sueldo_referencia * ___ * _______

# Ver el resultado
costo_rotacion
```

```{r objeto-hint-1}
# Asigna el elemento 'bajas' un valor cualquiera. Por ejemplo, las desvinculaciones en tu empresa en los √∫ltimos 12 meses 
# Para calcular el costo de rotaci√≥n multiplica sueldo_referencia * 6 * bajas
```

```{r objeto-hint-2}
# Crea los valores de referencia
sueldo_referencia <- 1000
bajas <- 18

# Calcular el costo de rotaci√≥n multiplicando ambos objetos por 6
costo_rotacion <- sueldo_referencia * 6 * bajas

# Ver el resultado
costo_rotacion
```

## Repaso: Vectores

Los vectores son conjuntos de datos. Los creamos con una funci√≥n llamada `c()` que significa *combine* (combinar).

Por ejemplo:

```{r vec-ej1, echo=TRUE}
# Vector num√©rico
numeros <- c(16, 8, 42)

# Vector de texto
texto <- c("RH", "People Analytics", "IA")

# Ver sus contenidos
numeros
texto
```

**Pregunta:** ¬øQu√© tipo de vector genera este c√≥digo?

```{r vec-ej2, eval=FALSE, echo=TRUE}
ejercicio <- c("1", 7, 9)
```

```{r vec-quizz}
quiz(
  question("¬øQu√© tipo de vector genera el c√≥digo anterior?",
           answer("Num√©rico", message = "Si bien son tres valores num√©ricos, el hecho de que el primero est√© entre comillas, hace que R lo considere un tipo de dato character o de texto"),
           answer("Texto", correct = TRUE, message = "Correcto! Cuando a un n√∫mero lo escribimos entre comillas R lo interpreta como texto"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE
)
)
```

Para seleccionar elementos de un vector tenemos que seguir la l√≥gica `nombre_vector[numero_posicion]`.

```{r vec-ej3, exercise = TRUE, exercise.lines =12}
# Crear un vector
area <- c("RH", "HR Analytics", "IA")

# Seleccionar el segundo elemento
_______

# Modificar el segundo elemento por 'People Analytics'
____[__] <- ____________

# Ver el vector actualizado
```

```{r vec-ej3-hint-1}
# Para elegir un elemento de un vector pone el nombre del vector y entre corchetes el n√∫mero del elemento
# Para asignar un valor hay que usar la estructura nombre_vector[elemento] y asignar el nuevo elemento

```

```{r vec-ej3-hint-2}
# Crear un vector
area <- c("RH", "HR Analytics", "IA")

# Seleccionar el segundo elemento
area[2]

# Modificar el segundo elemento por 'People Analytics'
area[2] <- "People Analytics"

# Ver el vector actualizado
area
```

## Repaso: Data frames

Los *data frames* son tablas, como las que encontramos en cualquier archivo de Excel por ejemplo, en donde tenemos filas (observaciones) y columnas (variables).

Si tenemos vectores que tienen la misma cantidad de elementos, podemos usar la funci√≥n `data.frame()` pasando los nombres de los vectores dentro de la funci√≥n.

Por ejemplo, creemos dos vectores, uno con el nombre de las √°reas de `RH`, `Finanzas` y `Operaciones`, y otro con la cantidad de colaboradores, por ejemplo: `6`, `12`, `24` respectivamente. Luego con esos vectores podemos crear un data frame llamado `dotacion`.

```{r df-1, exercise = TRUE, exercise.lines = 9}
# Crear los vectores 'area' y 'cantidad'
area <- c("RH", _______, ______)
cantidad ___ _(____, _____, _____)

# Crear el data frame usando la funci√≥n data.frame()
_______ <-  data.frame(________, ________)

# Ver el data frame
___________________
```

```{r df-1-hint-1}
# Asigna los 3 elementos a cada vector

# Crea un nuevo objeto llamado 'dotacion' 

# Escribe dentro del data frame los nombres de los vectores

# Para ver el data frame escribe su nombre
```

```{r df-1-hint-2}
# Crear los vectores 'area' y 'cantidad'
area <- c("RH", "Finanzas", "Operaciones")
cantidad <- c(6, 12, 24)

# Crear el data frame usando la funci√≥n data.frame()
dotacion <- data.frame(area, cantidad)

# Ver el data frame
dotacion
```

Corre la siguiente l√≠nea de c√≥digo y responde la pregunta a continuaci√≥n:

```{r df-2, exercise=TRUE}
# El data frame plantel ya est√° cargado
str(plantel) # Brinda informaci√≥n sobre la estructura del data frame
```

Responde la pregunta:

```{r df-3}
quiz(
  question(
    "¬øCu√°ntas filas y columnas tiene el dataframe 'plantel'?",
  answer("522 columnas y 8 variables", message = "Las observaciones son las filas y las variables son las columnas. Columna es sin√≥nimo de variable en R."),
  answer("522 variables y 8 filas", message = "Mir√° de nuevo la primera fila del resultado de la estructura del dataframe plantel. Primero indica las observaciones, y luego las variables"),
  answer("522 filas y 8 columnas", correct = TRUE, message = "Muy bien!"),
  submit_button = "Enviar respuesta",
  try_again_button = "Intenta de nuevo",
  allow_retry = TRUE
  )
)
```

## Paquetes

Los paquetes o librer√≠as son extensiones desarrolladas por la comunidad o por empresas que facilitan el uso de R y expanden sus capacidades. En este encuentro vamos a usar los siguientes paquetes:

-   `readxl`: Desarrollado por Hadley Wickham and Jennifer Bryan. [Link a la web](https://CRAN.R-project.org/package=readxl).
-   `openxlsx`: Desarrollado por Philipp Schauberger and Alexander Walker. [Link a la web](https://CRAN.R-project.org/package=openxlsx).
-   `tidyverse`: Desarrollado por Hadley Wickham y muchos m√°s. [Link a la web](https://www.tidyverse.org/).

Este √∫ltimo paquete, `tidyverse` es una colecci√≥n de paquetes que permiten realizar muchas tareas de exploraci√≥n, limpieza y transformaci√≥n de datos.

Para utilizar un paquete, lo primero que tenemos que hacer es instalarlos. Eso lo hacemos con la funci√≥n `install.packages()` y dentro del par√©ntesis tenemos que poner el nombre del paquete. **Tengan en cuenta que:**

-   R es un lenguaje *case sensitive* o sea que hay que prestar atenci√≥n a may√∫sculas y min√∫sculas.

-   Para instalar los paquetes hay que usar comillas

Este es un paso que hacemos una sola vez por computadora.

Para correr el c√≥digo se tienen que parar en la l√≠nea de c√≥digo que quieren usar y apretar las teclas `Ctrl` + `Enter` o bien el tri√°ngulo verde (como si fuera un √≠cono de *"Play"* ‚ñ∂Ô∏è)

```{r paquetes1, eval = FALSE}
# Instalar los paquetes readxl y tidyverse
install.packages("tidyverse")
install.packages("readxl")
```

Esto lo que hace es instalar paquetes desde [CRAN](https://cran.r-project.org/), que es un repositorio donde se publican los paquetes, asegurando un est√°ndar de calidad y de documentaci√≥n que hace que trabajar con cualquier paquete de CRAN sea seguro.

Para usar las funciones de los paquetes que instalamos, ahora tenemos que **cargarlos.** Esto lo que hace es de alguna manera *"activar"* el paquete y que podamos empezar sus funciones.

Para cargar un paquete tenemos que usar la funci√≥n `library()`. Recuerden prestar atenci√≥n a las may√∫sculas y min√∫sculas. Ahora no son necesarias las comillas.

```{r carga-paquetes, exercise = TRUE}
# Cargar los paquetes readxl y tidyverse
library(____)  # Leer archivos de Excel en R


```

```{r carga-paquetes-hint1}
# Ten√©s que usar la funci√≥n library() y dentro de los par√©ntesis escribir readxl

```

```{r carga-paquetes-solution}
# Cargar los paquetes readxl y tidyverse
library(readxl) # Leer archivos de Excel en R
```

Una de las formas en las que nos damos cuenta que el paquete est√° instalado es cuando empezamos a escribir su nombre y nos aparece el nombre del paquete para autocompletar. Esta es una de las ventajas de trabajar en RStudio.

![](images/paquete_activo.png)

> Recuerden:
>
> La instalaci√≥n de los paquetes se hace **una sola vez** por computadora.
>
> La carga de los paquetese se hace **cada vez que se abre** un script.

### Preguntas

En este primer ejercicio tendr√°s que corregir el c√≥digo para activar el paquete `tidyverse`. ¬øCu√°l es la funci√≥n que ten√©s que usar para lograrlo?

```{r activar-paquete, exercise = TRUE, exercise.lines = 4}
_______(tidyverse)
```

```{r activar-paquete-hint}
# Para instalar o activar un paquete revisa que el nombre no tenga errores de tipeo.
# R es case sensitive, controla que las may√∫sculas o min√∫sculas est√©n bien.
# Recuerda que no son necesarias las comillas.
library(tidyverse)
```

```{r paquetes2}
quiz(
  question("¬øCu√°ntas veces hay que instalar un paquete?",
           answer("Una sola vez por computadora", correct = TRUE, "As√≠ es! Este es un proceso que se hace por √∫nica vez en cada m√°quina en la que trabajes"),
           answer("Cada vez que corremos un script", message = "La instalaci√≥n s√≥lo es necesaria una sola vez"),
           answer("Cada vez que creamos un proyecto nuevo", message = "No importa la cantidad de proyectos. Cada vez que instalamos un paquete queda disponible para todos los proyectos que creemos."),
           answer("Depende", message = "[Depende](https://youtu.be/dgf5QlcyTFY) es una bonita canci√≥n de Jarabe de Palo y en este caso es una respuesta incorrecta ;p"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE),
  question("Cada vez que abro un script es necesario correr la funci√≥n `library()`",
           answer("Verdadero", correct = TRUE, message = "Si, es correcto, cada vez que abrimos R tenemos que correr el script desde el principio y vover a activar los paquetes."),
           answer("Falso", message = "Cada vez que abrimos el script hay que correr todo el c√≥digo desde el principio y activar el paquete con la funci√≥n library"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE),
  question("¬øPor qu√© aparece este mensaje de error?: 'no se pudo encontrar la funci√≥n _________'",
  answer("Porque el paquete no est√° instalado", message = "Es posible, pero hay otra respuesta m√°s espec√≠fica"),
  answer("Porque no cargamos el paquete con la funci√≥n library() antes", correct = TRUE, message = "Perfecto! La funci√≥n library() activa las funciones"),
  answer("Porque est√° mal escrito el nombre del paquete", message = "Si hay un error de tipeo el mensaje dir√≠a: there is no package called ___"),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE
))
```

Es un buen momento para [poner una pausa](https://youtu.be/xxLhW_hnrW4).

## Tidyverse

![](images/tidyverse_packages.png){width="400"}

`tidyverse` es un conjunto de paquetes, dise√±ados principalmente para la manipulaci√≥n y transformaci√≥n de datos. Tambi√©n es un est√°ndar, conocido como *tidy data* en el cual sus principios son:

-   Cada variable debe tener su propia columna.
-   Cada observaci√≥n debe estar en su propia fila.
-   Cada valor debe estar en su propia celda.

![Fuente: R para Ciencia de Datos](https://es.r4ds.hadley.nz/diagrams_w_text_as_path/es/tidy-1.svg){width="600"}

Un ejemplo t√≠pico de lo que tenemos que hacer es cuando en un archivo de Excel nos encontramos con algo as√≠:

![Datos Anchos](images/datos_anchos.png)

Para R, enero, febrero, y marzo son valores de una variable que se llamar√≠a mes. Si necesito hacer c√°lculos o un gr√°fico con sus resultados necesito poner esa variable en una columna en vez de en un fila como est√° ahora.

![Datos largos](images/datos_largos.png)

En este primer curso trabajamos mucho con el paquete `dplyr` que nos permite filtrar datos, unir datos de diversas fuentes, y hacer las transformaciones necesarias para poder realizar nuestros an√°lisis. Para saber m√°s del resto de los paquetes de tidyverse busc√° en el [Google Drive](https://drive.google.com/drive/folders/1Qck3z_t6XLRXb2vbN-00931DgdJZ0yse?usp=sharing) de **R4HR Club de R para RRHH** o mir√° los videos en [YouTube](https://youtube.com/playlist?list=PLZuVytUJrxQlcqu6l-P3ou4vV2mRJU2Ka).

## Funciones o verbos de dplyr

Ten√© a mano el [cheatsheet de data-wrangling](https://drive.google.com/file/d/1ViFJRuby7FTDgjWvp9P6hKO3MEHgeH_M/view?usp=sharing) en castellano. Los cheatsheets (machetes, cola, trencito, torpedo, chuleta, copiat√≠n, plage, chanchullo, etc.) son ayuda memoria con las principales funciones de un paquete.

Las funciones que vimos en el curso (que no son todas las del paquete) son:

-   **left_join():** Permite unir informaci√≥n de varias tablas. Los sistemas de gesti√≥n de RRHH tienen por ejemplo una tabla que tiene informaci√≥n b√°sica de las personas (nombre y apellido, fecha de nacimiento, etc.), otra tabla con la remuneraci√≥n base y los conceptos salariales que le correspondan, y podr√≠a tener otras tablas con las evaluaciones de desempe√±o y as√≠ sucesivamente. Hay muchos tipos distintos de `join`, pero a los fines pr√°cticos de este curso nos quedaremos con `left_join()` que es una funci√≥n equivalente a realizar un *buscarv* o un *vlookup* en Excel.

-   **select():** Permite seleccionar las columnas con las que queremos trabajar. Tambi√©n permite acomodarlas en el orden que las necesitemos, y tambi√©n la podemos usar para descartar variables que no necesitemos.

-   **filter():** Nos permite filtrar las filas que cumplan con una o m√°s condiciones. Por ejemplo, si queremos hacer un an√°lisis de un grupo espec√≠fico de empleados (por ejemplo L√≠deres), vamos a filtrar de una tabla de empleados, los empleados que tengan una posici√≥n de liderazgo.

-   **group_by():** Por ejemplo, si quiero analizar los sueldos promedios por puesto, un paso previo que tenemos que hacer es *agrupar* los datos por la variable `puesto` antes de calcular el promedio. Es un paso previo que realizaremos siempre antes de hacer alg√∫n c√°lculo de resumen estad√≠stico.

-   **summarise():** Es la funci√≥n que nos permite hacer c√°lculos de resumen estad√≠stico (calcular promedios, medianas, contar filas, desv√≠os est√°ndares, etc.). Lo

-   **mutate():** Uno de los principales usos de `mutate()` es el de crear una nueva variable (columna) en nuestro dataframe original en base a alguna columna que ya exista. Por ejemplo, si tengo una columna que contenga el sueldo b√°sico mensual de un empleado, podr√≠a a√±adir otra columna que calcule las cargas sociales, o bien el costo anual de cada colaborador/a. Otro uso que se le da es para modificar las caracter√≠sticas de una variable (lo veremos en un ejercicio).

## El "pipe" %>%

Uno de los paquetes de tidyverse, el paquete `dplyr` aporta un s√≠mbolo conocido como *"pipe"* `%>%` (*tubo* en ingl√©s). El atajo de teclado es con las teclas *Ctrl +Shift +M* en Windows, o *Cmd + Shift + M* en Mac.

A partir de la versi√≥n 4.1.0 de R, hay una versi√≥n nativa de R del *pipe* cuyo s√≠mbolo es `|>` pero en este curso utilizaremos la versi√≥n del paquete `dplyr`.

Lo que nos permite este *pipe* o *tubo* es escribir los c√≥digos en secuencias, haciendo much√≠simo m√°s f√°cil escribir y leer secuencias de funciones que incluyan varios pasos.

Imaginemos que queremos comprar regalos por el d√≠a del ni√±o a todos los empleados de la empresa que tengan hijos. Para esto, necesitamos un listado de los empleados que tengan hijos, ordenados por sector. Para lograr esto los pasos que tenemos que seguir son:

1.  Seleccionar las columnas `AREA`, `ID` e `HIJOS` del dataframe `nomina`.

2.  Filtrar los empleados que tengan hijos (donde en la columna `HIJOS` el valor sea mayor que cero.

3.  Ordenar los resultados por `AREA`.

Veamos c√≥mo se ve el c√≥digo de R sin el uso del pipe `%>%`:

```{r ej3, echo=TRUE, eval=FALSE}

# Ejemplo de funciones anidadas sin usar el pipe
arrange(filter(select(nomina, AREA,ID, HIJOS), HIJOS > 0), AREA)
```

Ahora veamos el siguiente c√≥digo, que logra lo mismo que antes, pero usando el pipe `%>%`

```{r ej4, echo=TRUE, eval=FALSE}
# Ejemplo de funciones anidadas usando el pipe
nomina %>% 
  select(AREA, ID, HIJOS) %>% 
  filter(HIJOS > 0) %>% 
  arrange(AREA)
```

¬øCu√°l de las dos formas anteriores te parece la forma m√°s sencilla de entender la secuencia de an√°lisis? ¬øLa versi√≥n sin el pipe, o con el pipe?

## Unir datos con left_join()

Tenemos dos dataframes, uno con informaci√≥n general de los empleados. El dataframe `plantel` contiene 8 variables:

-   ID: el dato de identificaci√≥n √∫nica de cada persona de la empresa.

-   ANTIGUEDAD: Los a√±os de permanencia en la organizaci√≥n.

-   EDAD: La edad de los colaboradores.

-   ESTADO_CIVIL: El estado civil de los trabajadores/as de la compa√±√≠a.

-   HIJOS: La cantidad de hijos que tiene cada colaborador.

-   AREA: El sector en el que trabaja cada persona.

-   ID_CAT: La clave identificatoria de las categor√≠as de los trabajadores.

-   N_CATEG: El nombre de cada categor√≠a.

Veamos la estructura del dataframe.

```{r str1, exercise = TRUE}
#Correr este c√≥digo
str(plantel)
```

El siguiente dataframe, `salarios` contiene los siguientes campos:

-   ID: el campo que nos permitir√° unir las diferentes tablas.

-   PUESTO: el nombre real del puesto que ocupa cada persona.

-   SUELDO: La remuneraci√≥n b√°sica mensual de cada empleado.

Prest√° atenci√≥n a la estructura del archivo y contesta la siguiente pregunta.

```{r str2, exercise = TRUE}
str(salarios)
```

```{r left-q}
quiz(
  question("¬øCu√°ntas filas y columnas tiene el dataframe 'salarios'?",
  answer("135 columnas y 3 variables", message = "Las observaciones son las filas y las variables son las columnas"),
  answer("130 filas y 10 variables", message = "Mir√° de nuevo el resultado de la estructura del dataframe salarios. Primero indica las observaciones, y luego las variables"),
  answer("135 filas y 3 columnas", correct = TRUE, message = "Muy bien!"),
  submit_button = "Enviar respuesta",
  try_again_button = "Intenta de nuevo",
  allow_retry = TRUE
))
```

Ahora vamos a unir ambos dataframes en uno solo para poder hacer nuestros an√°lisis.

Usaremos la funci√≥n `left_join()` para agregar al dataframe `plantel` los datos del dataframe `salarios.`

```{r leftjoin, exercise = TRUE, exercise.lines=7}
# Agrega al dataframe 'plantel' el dataframe 'salarios'
empleados <- left____(_____, _____, by = "ID")

# Ver la estructura del nuevo dataframe
___(__________)
```

```{r leftjoin-hint}
# Recuerda poner la funci√≥n left_join()
# A√±ade al dataframe 'plantel', los datos de 'salarios' por la columna ID
# Cuidado con may√∫sculas y min√∫sculas
# Para ver la estructura del dataframe usa la funci√≥n str(nombre_dataframe)
```

```{r leftjoin-solution}
empleados <- left_join(plantel, salarios, by = "ID")

# Ver la estructura del nuevo dataframe
str(empleados)
```

Hay muchos tipos de `join`, por ejemplo `right_join`, `inner_join`, `anti_join`, `full_join`, que no ser√°n parte de este curso.

## select()

Con la funci√≥n `select()` podemos elegir las columnas que nos interesa trabajar. Por ejemplo, prueba de correr la funci√≥n `str()` con el nuevo dataframe `empleados`.

Esta es una funci√≥n particularmente √∫til cuando trabajamos con datasets muy grandes que contienen muchas columnas y filas, que mejora los tiempos de procesamiento de datos.

```{r str, exercise = TRUE, exercise.lines = 5, exercise.setup="fuente"}
# Corre esta l√≠nea de c√≥digo
str(empleados)
```

Las variables `EDAD`, `ESTADO_CIVIL` e `HIJOS` no tienen mucho sentido para un an√°lisis salarial. En el pr√≥ximo ejercicio, selecciona las columnas `ID`, `AREA`, `PUESTO`, `SUELDO`, y `ANTIGUEDAD` y guarda la selecci√≥n en un objeto llamado `mensuales.`

```{r select, exercise = TRUE, exercise.lines = 5, exercise.setup="fuente"}
mensuales <- empleados %>% 
  _______(___, ___, ____, ____)

# Ver el resultado
_________
```

```{r select-hint}
# Usa la funci√≥n select()
# Dentro del par√©ntesis pon los nombres de las variables que nos interesa analizar
```

```{r select-solution}
mensuales <- empleados %>%          # Crea un nuevo dataframe con los datos de empleados
  select(ID, AREA, PUESTO, SUELDO)  # Selecciona las variables de inter√©s

# Ver el resultado
mensuales
```

### Pregunta

Varias funciones de `dplyr` tienen algunas variantes auxiliares. ¬øPor ejemplo, qu√© cre√©s que hace el siguiente c√≥digo?

```{r qselect, echo=TRUE, eval=FALSE}
plantel %>% 
  select_if(is.numeric)
```

```{r qselect1}
quiz(question("¬øQu√© har√° la funci√≥n select_if(is.numeric)?",
         answer("Selecciona las columnas si son num√©ricas", 
                correct = TRUE, 
                message = "Perfecto, select_if(is.numeric) seleccionar√° todas las columnas num√©ricas"),
         answer("Selecciona las columnas si no son num√©ricas",
                message = "Incorrecto, todo lo contrario"),
         answer("No es una funci√≥n real",
                message = "Incorrecto, es una funci√≥n real, y en algunos casos muy pr√°ctica"),
         submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE)
         )
```

## filter()

La funci√≥n `select()` elige columnas, `filter()` por otro lado, nos permite seleccionar filas que coincidan con un criterio de filtro para determinar qu√© casos pasan cu√°les no lo hacen.

Para trabajar con filter vamos a necesitar algunos *operadores l√≥gicos*:

```{r filter}
library(gt)
gt(
  data.frame(
    "S√≠mbolo" = c("<", "<=", ">", ">=", "==", "!=", "&", "|"),
    "Significado" = c("menor a", "menor o igual a", "mayor a", "mayor o igual a",
                "igual a", "distinto a", "y (and)", "o (or)")
  )
) %>% 
  cols_align(
    align = "center",
    columns = everything()
  )
```

Hay que prestar mucha atenci√≥n cuando decimos coloquialmente por ejemplo *"filtrar √°rea igual a RRHH"* porque el s√≠mbolo que hay que usar es `==` y no `=`. ¬øPor qu√©?

-   ‚úîÔ∏è`AREA == "RRHH"` va a filtrar todas las filas de la columna *AREA* que digan *RRHH*.

-   ‚ùå`AREA = "RRHH"` va a crear un objeto en la memoria que se llamar√° *AREA* y cuyo valor ser√° *RRHH*

En mi opini√≥n, es tambi√©n un punto a favor del uso de la *"flechita"* (`<-`) para crear objetos, ya que el signo igual lo usamos para modificar par√°metros dentro de las funciones.

Entonces, ¬øc√≥mo hago para seleccionar a las personas del `AREA` de `FINANZAS`?

```{r sel1, exercise=TRUE, exercise.lines=6}
# Primero indico el nombre del dataframe
empleados %>% 
# Luego ejecuto el filtro  
  filter(AREA __ "FINANZAS")
```

```{r sel1-hint}
# Revisa la tabla de operadores l√≥gicos de m√°s arriba
# ¬øCu√°ntos s√≠mbolos 'igual' (=) necesit√°s? ¬ø1 o 2?
```

```{r sel1-solution}
# Primero indico el nombre del dataframe
empleados %>% 
# Luego ejecuto el filtro  
  filter(AREA == "FINANZAS")
```

Es importante que cuando estemos filtrando una variable categ√≥rica usemos las comillas para nombrar la condici√≥n por la que queremos filtrar los datos.

El signo de exclamaci√≥n (`!`) sirve en R como un operador de negaci√≥n. Por ejemplo, si escribimos:

```{r sel-ejemplo, echo=TRUE, eval=FALSE}
empleados %>% 
  filter(AREA != "RRHH")
```

Lo que obtendremos ser√°n todos los empleados que **no sean de RRHH**.

### Mensajes de error

Un error frecuente que cometemos cuando estamos aprendiendo a usar la funci√≥n `filter()` es poner un s√≥lo signo igual en vez de dos. Revisemos el mensaje de error que obtenemos:

```{r error1, eval=FALSE, include=TRUE, echo=TRUE}
# Este c√≥digo contiene un error
plantel %>% 
  filter(AREA = "RRHH")
```

El mensaje que obtenemos dice lo siguiente:

![](images/filter_error_igual.png)

Estos son los pasos que tenemos que seguir cuando corremos un c√≥digo y nos sale un mensaje de error:

1.  Entrar en p√°nico üò±
2.  Si de la computadora no sale humo, respirar con alivio hasta recuperar la calma üßò
3.  Leer el mensaje de error üë©‚Äçüíª
4.  En caso de no entender el mensaje, pegar un print de pantalla en el canal **#auxilio** del [grupo de Slack](https://join.slack.com/t/r4hr/shared_invite/zt-ocriyx5e-nqXuwWeDyOKm2ICUJjhu6g) üôã que alguien siempre va a ayudar.
5.  Una alternativa al paso 4 es buscar en Google. Suena como un chiste pero no lo es, saber buscar soluciones en Google, foros y sitios como Stack Overflow es parte del trabajo de un Data Scientist üíª

Si no me creen, miren este tuit de Hadley Wickham

![](images/hadley_google.png)

Si no saben qui√©n es Hadley, miren [su perfil en LinkedIn](https://www.linkedin.com/in/hadleywickham/).

El mensaje de error anterior nos da un par de pistas despu√©s de la `i`

*This usually means that you've used* '=' *instead of '=='.*

*Did you mean 'AREA == "RRHH"'?*

Traduciendo esto nos dice que: *Esto usualmente significa que has usado '=' en vez de '=='. ¬øQuer√≠as decir 'AREA == "RRHH"'?*

O sea que lo que tenemos que hacer para corregir el error anterior es poner dos signos igual (`==`) dentro de `filter()`.

> Recuerden que programar es aprender a ejercitar la tolerancia a la frustraci√≥n. Los errores son parte de la programaci√≥n, incluso en los programadores experimentados.

```{r error2, exercise=TRUE}
# Este c√≥digo contiene un error, corr√≠gelo
plantel %>% 
  filter(AREA = "RRHH")
```

```{r error2-hint-1}
# Para filtrar por un valor espec√≠fico necesitamos dos signos iguales
```

```{r error2-hint-2}
# Este c√≥digo contiene un error, corr√≠gelo
plantel %>% 
  filter(AREA == "RRHH")
```

Otro error habitual, cuando la columna por la que queremos filtrar es de tipo `character` o `factor` es no poner las comillas (que no son necesarias con variables num√©ricas). Veamos el mensaje de error.

![](images/filter_error_comillas.png)

Nuevamente, la pista la tenemos detr√°s de la letra `i`

*i Input '..1' is 'AREA == RRHH'*

*x objeto 'RRHH' no encontrado*

Si lo traducimos dice que input es AREA == RRHH, y luego nos dice que no encontr√≥ el objeto RRHH. En este caso, que tenemos la certeza de que RRHH est√° bien escrito (recuerden que R es case sensitive) el problema es que nos faltan las comillas en `"RRHH"`.

### Filtrando varios elementos a la vez

Muchas veces queremos seleccionar varios elementos de una sola vez. Para esto tenemos dos alternativas.

La primera es usando el operador l√≥gico **O** (OR) con el s√≠mbolo `|`. Busquemos las personas que trabajan en `RRHH` y en `FINANZAS`.

```{r filters, exercise=TRUE}
# Reemplazar el espacio con el operador l√≥gico | 
plantel %>% 
  filter(AREA == "RRHH" ___ AREA == "FINANZAS")
```

```{r filters-hint}
# Reemplazar el espacio con el operador l√≥gico | 
plantel %>% 
  filter(AREA == "RRHH" | AREA == "FINANZAS")
```

Cuando las opciones son m√°s de dos, la mejor forma de filtrar elementos es usando el operador `%in%` en conjunto con un vector que tenga los valores que nos interesa filtrar. La sintaxis es la siguiente:

```{r filters2, eval=FALSE, include=TRUE, echo = TRUE}
data.frame %>% 
  filter(variable %in% vector)
```

Seleccionar las personas que trabajan en `COMPRAS`, `FINANZAS` y `RRHH`.

```{r filters3, exercise = TRUE, exercise.lines = 4}
# Filtar en la columna AREA las filas que contengan COMPRAS, FINANZAS y RRHH usando un vector
plantel %>% 
  filter(_____ ____ _________))
```

```{r filters3-hint-1}
# Poner primero la columna que quiero filtrar, usar el operador %in% y luego dentro del vector los nombres de las √°reas.
# Los nombres de los sectores est√°n con todas las letras en may√∫sculas.
```

```{r filters3-solution}
# Filtar en la columna AREA las filas que contengan COMPRAS, FINANZAS y RRHH usando un vector
plantel %>% 
  filter(AREA %in% c("COMPRAS", "FINANZAS", "RRHH")))
```

### Filtrar celdas vac√≠as

Las celdas vac√≠as, representadas en R por un `NA` son un problema. Por ejemplo si quisiera sacar un promedio de la variable `satisfaccion` del data frame `encuesta` no podr√≠a porque contiene valores nulos.

```{r filter-na, exercise = TRUE, exercise.lines = 6}
# Hacer un summary de encuesta$satisfaccion
________(_______$___________)

# Probemos calcular un promedio sobre la columna satisfaccion
mean(encuesta$satisfaccion)
```

```{r filter-na-hint}
# Hacer un summary de encuesta$satisfaccion
summary(encuesta$satisfaccion)

# Probemos calcular un promedio sobre la columna satisfaccion
mean(encuesta$satisfaccion)
```

La columna satisfacci√≥n tiene 75 `NA`. Y cuando queremos calcular el promedio de esa columna, el resultado es un `NA`. Prueben agregar el par√°metro `na.rm = TRUE` dentro de la funci√≥n `mean()` que elimina del c√°lculo las celdas vac√≠as.

Si quisi√©ramos seleccionar las filas que no tengan datos nulos podemos hacerlo de la siguiente manera, usando la funci√≥n `is.na()`. Esta funci√≥n hace una evaluaci√≥n sobre la celda est√° vac√≠a o no. Si esta vac√≠a el resultado ser√° `TRUE`, de lo contrario, ser√° `FALSE`.

Para quedarnos con las filas que s√≠ contienen datos tenemos que anteponer el operador de negaci√≥n `!`. Vamos a usar una funci√≥n llamada `pull()` para *extraer* los valores de la columna y pasarlos a un vector.

```{r filter-na2, exercise=TRUE, exercise.lines = 12}
# Probar la funci√≥n is.na()
is.na(encuesta$satisfaccion)

# Seleccionar la columna satisfaccion, filtrar los no nulos y calcular el promedio
satisfaccion <- encuesta %>% 
  select(satisfaccion) %>% 
  filter(_____(______)) %>% 
  pull()                    # Extrae la columna del data frame y la guarda como un vector

# Calcular el promedio de satisfaccion
mean(satisfaccion)
```

```{r filter-na2-hint-1}
# Poner dentro del filter() todo lo que NO SEA un NA

# Usar el operador ! antes de la funci√≥n is.na()

# Estar atentos a los par√©ntesis
```

```{r filter-na2-hint-2}
# Probar la funci√≥n is.na()
is.na(encuesta$satisfaccion)

# Seleccionar la columna satisfaccion, filtrar los no nulos y calcular el promedio
satisfaccion <- encuesta %>% 
  select(satisfaccion) %>% 
  filter(!is.na(satisfaccion)) %>% 
  pull()                    # Extrae la columna del data frame y la guarda como un vector

# Calcular el promedio de satisfaccion
mean(satisfaccion)
```

### Pr√°ctica

Filtrar las personas que tengan 55 a√±os o m√°s del data frame `plantel`.

```{r prac-fil, exercise=TRUE}
# Filtrar empleados que tengan 55 a√±os o m√°s
plantel %>% 
  ______(______)
```

```{r prac-fil-hint-1}
# Usar la funci√≥n filer de la variable EDAD

# El operador l√≥gico que necesitamos es mayor o igual >= 
```

```{r prac-fil-hint-2}
# Filtrar empleados que tengan 55 a√±os o m√°s
plantel %>% 
  filter(EDAD >= 55)
```

Volvamos a realizar un `left_join()` de `plantel` y de `salarios` y guardarlo en un objeto que se llame `mensuales`. Luego filtrar todo lo que no sea `NA` de la columna `PUESTO`.

```{r prac-fil2, exercise = TRUE, exercise.lines=12}
# Almacenar en un data frame llamado mensuales, un left_join de plantel y salarios
__________ <- left_join(_______, ________, by = "ID")

# Filtrar todo lo que no sea NA de la columna PUESTO. Sobrescribir el data frame mensuales
_________ <- __________ %>% 
  filter(____(________))

# Darle un vistazo al data frame mensuales con la funci√≥n glimpse()
glimpse(mensuales)
```

```{r prac-fil2-hint-1}
# Crear un objeto llamado mensuales

# En el left_join() poner primero plantel, y luego salarios

# Usar !is.na() para filtrar todo lo que no sea un NA
```

```{r prac-fil2-hint-2}
# Almacenar en un data frame llamado mensuales, un left_join de plantel y salarios
mensuales <- left_join(plantel, salarios, by = "ID")

# Filtrar todo lo que no sea NA de la columna PUESTO. Sobrescribir el data frame mensuales
mensuales <- mensuales %>% 
  filter(!is.na(PUESTO))

# Darle un vistazo al data frame mensuales con la funci√≥n glimpse()
glimpse(mensuales)
```

Gran momento para meter una pausa.

<iframe width="560" height="315" src="https://www.youtube.com/embed/FlDGFrP4NgI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>

</iframe>

## group_by() y summarise()

![](https://c.tenor.com/WI1L43K5gR4AAAAC/harry-potter-weasley-twins.gif){width="365"}

Las funciones `group_by()` y `summarise()` se usan juntas pr√°cticamente todo el tiempo. Son muy √∫tiles cuando nos piden hacer algunos c√°lculos para poblaciones espec√≠ficas o de inter√©s. Por ejemplo, cuando decimos:

-   *Quiero saber la antig√ºedad promedio por categor√≠a*, agrupamos por categor√≠a y calculando por edad.

-   *Quiero saber la mediana salarial por g√©nero* estamos agrupando por g√©nero y calculando por sueldo.

-   *Quiero saber la antig√ºedad m√°xima por sector* estamos agrupando por sector y calculando por antiguedad.

El grupo lo creamos con `group_by()` y el c√°lculo lo hacemos con `summarise()`.

Con `group_by()` lo que hacemos es agrupar todas las filas de un data frame y reducirlas a una cantidad m√°s chica de filas. La cantidad de filas va a estar determinada por la cantidad de valores √∫nicos que haya en una columna.

Por otro lado `summarise()` lo que hace es a√±adir una columna nueva a ese data frame agrupado con alg√∫n c√°lculo que nos interese realizar. Esto, en la jerga de analytics o data science se le dice *hacer un c√°lculo de resumen estad√≠stico*. ¬øPor qu√©? Porque lo que intentaremos hacer es resumir por ejemplo los sueldos, a una medida estad√≠stica como la mediana, la antig√ºedad a un promedio, y as√≠ sucesivamente.

Veamos algunos ejemplos:

### Ejemplos de group_by() y summarise()

Hagamos una primera prueba, calculemos los a√±os de experiencia promedio por puesto:

```{r group_by1, exercise=TRUE}
# Ejecuta esta l√≠nea de c√≥digo
encuesta %>% 
  group_by(puesto) %>% 
  summarise(antiguedad_promedio = mean(anios_experiencia))
```

En el ejemplo anterior, agrupamos por la variable `puesto`. Este campo tiene 6 valores posibles (en orden alfab√©tico): *Administrativo, Analista, Gerente, HRBP, Jefe* y *Responsable*. Por lo tanto el data frame de salido, tiene 6 filas.

Con `summarise()` lo que hicimos fue a√±adir una columna, con el nombre `antiguedad_promedio` y el valor de cada celda es el promedio de los a√±os de antig√ºedad que hay en la variable `anios_experiencia`.

Los c√°lculos m√°s comunes que hacemos con `summarise()` son:

+---------------------+--------------+
| C√°lculo             | Funci√≥n      |
+:===================:+:============:+
| Promedio            | `mean()`     |
+---------------------+--------------+
| Mediana             | `median()`   |
+---------------------+--------------+
| Suma                | `sum()`      |
+---------------------+--------------+
| Contar              | `n()`        |
+---------------------+--------------+
| Desv√≠o Est√°ndar     | `sd()`       |
+---------------------+--------------+
| M√°ximo              | `max()`      |
+---------------------+--------------+
| M√≠nimo              | `min()`      |
+---------------------+--------------+

No son todas las funciones posibles, pero son las m√°s comunes `r emo::ji("biceps")`.

Hagamos un c√°lculo m√°s interesante: Calcula el sueldo promedio por puesto.

```{r group_by2, exercise = TRUE}
# Calcula el sueldo promedio por puesto. 
# Agrupa por puesto y hace el c√°lculo con sueldo_bruto
encuesta %>% 
  _______(______) %>% 
  _________(sueldo_promedio = mean(____________))
```

```{r group_by2-hint-1}
# Primero reemplaza los guiones por group_by para agrupar por 'puesto'.

# Us√° la funci√≥n summarise() para calcular el promedio de 'sueldo_bruto'
```

```{r group_by2-hint-2}
# Calcula el sueldo promedio por puesto. 
# Agrupa por puesto y hace el c√°lculo con sueldo_bruto
encuesta %>% 
  group_by(puesto) %>% 
  summarise(sueldo_promedio = mean(sueldo_bruto))
```

### Agrupar por m√°s de una variable

Tambi√©n es posible agrupar por m√°s de una variable. Veamos el sueldo promedio por g√©nero y tipo de universidad:

```{r group_by3, exercise = TRUE}
# Ejecuta esta l√≠nea de c√≥digo
encuesta %>% 
  group_by(genero, tipo_universidad) %>% 
  summarise(sueldo_promedio = mean(sueldo_bruto))
```

Del c√≥digo anterior podemos concluir que el tipo de universidad no hace una gran diferencia entre los salarios de las personas que estudiaron en universidades p√∫blicas o privadas, pero s√≠ hace una gran diferencia entre quienes fueron a la universidad y quienes no. De los datos obtenidos tambi√©n podemos apreciar que el g√©nero es tambi√©n un factor que explica las diferencias salariales entre hombres y mujeres.

El mensaje que obtenemos al agrupar por m√°s de una variable,*\`summarise()\` has grouped output by 'genero'. You can override using the \`.groups\` argument* simplemente indica que la variable que ponemos primero va a ser la que use como *"llave"* para agrupar. **En resumen, el resultado est√° bien.**

De la misma manera, podemos incluir m√°s de un c√°lculo dentro de `summarise()`. Solo hay que separar con una coma (`","`) las nuevas columnas con las medidas de resumen estad√≠stico que queramos hacer.

Por ejemplo, calculemos el sueldo promedio y el desv√≠o est√°ndar seg√∫n si las personas estudiaron en universidades p√∫blicas, o privadas.

```{r group_by4, exercise = TRUE, exercise.lines = 10}
# Crear un data frame eliminando a las persona que no estudiaron en la universidad
universitarios <- encuesta %>% 
  filter(tipo_universidad != "No estudi√© en la Universidad")

# Calcular el sueldo promedio y el desvi√≥ est√°ndar usando el data frame 'universitarios'
universitarios %>% 
  group_by(tipo_universidad) %>% 
  summarise(sueldo_promedio = _____(_______),
            sueldo_desvio = __(________))
```

```{r group_by4-hint-1}
# Con filter() nos quedamos con las filas cuyo valor NO ES "No estudi√© en la Universidad"

# Reemplazar los espacios en blanco con la funci√≥n y la variable (sueldo_bruto) que corresponden.
```

```{r group_by4-hint-2}
# Crear un data frame eliminando a las persona que no estudiaron en la universidad
universitarios <- encuesta %>% 
  filter(tipo_universidad != "No estudi√© en la Universidad")

# Calcular el sueldo promedio y el desvi√≥ est√°ndar usando el data frame 'universitarios'
universitarios %>% 
  group_by(tipo_universidad) %>% 
  summarise(sueldo_promedio = mean(sueldo_bruto),
            sueldo_desvio = sd(sueldo_bruto))
```


### Ejercicio group_by() + summarise()

Del data frame `mensuales` calcular el promedio salarial por puesto. No hace falta guardar los resultados en un objeto.




# mutate()
